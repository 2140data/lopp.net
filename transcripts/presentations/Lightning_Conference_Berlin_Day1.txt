Thanks for doing a good job.
We can hold up that queue, okay.
So, Lightning Conference of the Decade.
What do you think about that?
It's like, absolutely crazy.
So, welcome guys.
Thank you all for being here.
I mean, this is amazing to just have
this community come together.
Not just the developers, but businesses building on Lightning
and just general enthusiasts.
So, I think the last couple days have been a good way to kick it off.
So, we're finally here.
Yeah, it was fantastic.
It's the Socratic Seminar and the projects.
There's so many incredible speakers.
So, I'm really, truly excited.
I think this is going to be something
that people are going to look back on
in years to come and say,
well, this is where it sort of started.
So, that's fantastic.
Awesome. Before we kick it off,
we do want to thank our sponsors really quickly.
So, the foundation sponsors,
Lightning Labs, Async,
and Blockstream.
Yep, and our BTC level sponsors.
So, yes.
Yes.
Our BTC level sponsors, which is
BitMEX Research, who actually also
is sponsoring the coffee today,
and also BottlePay.
Yep.
The...
The bit
level sponsors, that's Bitstamp,
Iterative Capital, and
New York Digital Investment Group.
So, thanks to them as well.
And then
we have our sat level
sponsors, so Digital Garage,
Fidelity,
just lost my space,
Fulgur Ventures, HTC,
and Puzzle ITC.
Yep.
Yes.
We've also got some
scholarship sponsors
who paid for some individuals
to attend Craft Ventures
and Chaincode Labs.
So, thank you to them.
And we want to
thank Voltoro
for hosting the live stream today.
So, all the folks who are
watching in from home, this wouldn't be
possible without them.
Yep.
Yep.
The official opening party,
which was last night, sponsored by
Stackwork. So, thank you to
them.
And tonight,
if you haven't signed up,
Iterative Capital is hosting the after party
this evening at 8 o'clock.
So, yeah, definitely be there.
And thank you to Iterative Capital.
Okay.
So, guys, we've got an official
hashtag for the conference.
It's hashtag TLC 2019.
So, make sure you guys are
tweeting out there and helping
promote Lightning.
And also, CASA has generously
donated three node packages.
So, it's a node, some swag,
some other stuff. And we will be raffling
off on these three
nodes by basically
we're hosting a meme contest.
So, on Twitter, whoever
posts the best meme
during the conference in hashtags
TLC 2019
and also tags the conference,
we will be selecting the top
three. And those individuals will be
sent a CASA node package
after the conference. So,
definitely get in on the game.
We want to see your best memes.
Fantastic. So, just a couple of logistics.
We've got stage two.
If you go out and upstairs, stage two is
there. There's also a workshops area
as well. So, make sure
you go and check that out as well.
Yeah. And if you haven't taken a look,
the workshops are now listed on the Google
Doc that everyone received.
And I believe they're on this schedule as well.
So, if you didn't see those beforehand, definitely
take a look and stop by and check them out.
Yeah.
Food will be outside that direction as well.
One thing we did want to make a
quick note as well, another sort of
logistics point. We are on
a really tight schedule. We've got a lot of speakers.
We want to try and make sure we
get through everyone and we don't
run over time. So, what we're
asking is that you guys will
try to, when you're going away for a break, you're back
on time and you're ready to go for the next one
so that we can keep it rolling.
Yeah. And I think we're actually three
minutes ahead of schedule. So, good at our job.
So, yeah, I guess we can kick it off
with our first speaker. And we have
Jamison Lopp from CASA talking
about Enterprise Lightning.
Applause
Alright.
Pray that the technology gods are kind to us
today. I'm Jamison
Lopp. I'm a CTO of CASA.
And I'm actually here
today to talk about
why I believe enterprise
adoption of
lightning network technology is incredibly
important for the health
and optimal use
of the network. So,
while I have not been dealing with
rolling out enterprise
level lightning technology myself,
this is something that I've actually been thinking about
for almost four years now.
So, why
enterprise lightning? There are a few
of course
answers to that, like lower fees,
instant withdrawals.
These are obvious features of the
lightning network, which is why almost anybody
would want to use it over on chain
transactions. But
when we start to look at the economics
of what is in play,
think about the way
that your regular day-to-day
transactions work. And in fact,
if you think back
to the last transaction that you
have made personally,
was that with
a business or with an individual?
If your last transaction was with
a business, could you just raise your hand?
Looks like
a lot. So, if your last transaction that
you made in the real world
was with another individual, could
you raise your hand?
So, it seems like probably
the majority of
recent transactions were
with businesses. I think that you find
if you go back through your own
accounting ledger and
the payments that you've made, most of them of course
are going to be with companies with
enterprises that are providing services.
So, if we
make the assumption that the economics
on a mainstream adoption
lightning network are going to be
similar to what we're seeing today in the real
world, I think it makes a lot of sense
that we want to get as many enterprises
onboarded as possible.
And I'll go into a lot more detail about why I think
that is important. Also, another
of course answer is
we can get some improved privacy,
especially with various services that
are doing AML KYC.
I think that a lot of people would really prefer
to have a peace of mind that
they could make a deposit onto
an exchange or make a withdrawal from a
service and not have to worry about
the flow of that value
over the time
in the future being
tracked via on-chain analysis
or other methods.
The main point that I'm going to be
talking about in detail is that
the architecture of
the lightning network itself
is predicated upon
the idea that the net
flow of money in an
economy is close to zero.
It's that you have value
flowing in one direction, but eventually
it'll be flowing all around
and around, and you're not just moving
all of the value from one party
to another and it just sits there.
Any healthy economy is going to continuously have
value that is flowing
around and around through
various enterprises and individuals.
Just a sort of side
note, I don't think that
fee income is going to be much
of a driver of adoption,
but rather the savings
that enterprises are going to get
by not having to receive
tons of UTXOs and consolidate
them and pay lots of on-chain fees
to actually consume
those UTXOs. This was
a study that BitMEX research
did that showed
that maybe you could eke out about
a 1% annual
return on investment if you're really
good at routing, but that's also
very early days and I think
that over time, as lightning network
becomes greater and greater adopted, there's
going to be more and more competition for
routing of value through the network,
so the fees are probably going to go down.
Now, four years
ago, when I first started
researching this lightning network thing
because I wanted to write an article about
it, I asked Delalu, I was
like, hey man, what do you
have to say in response to all
these people who are saying, well
the economics of the lightning network
are going to result in an extreme level
of centralization, so
we're just going to end up with a few big hubs
and everybody else is going to be a spoke
off of those hubs.
And he responded to me
and he was like, well yeah man, the people
that are saying this, they actually got a really good
point because there's going to be a lot of centralization, there's
going to be some concentrated areas of
economic liquidity where you have bigger players,
but then also you're going to have some smaller players, and
then you're going to have a lot of individuals, and so what we really
think is going to happen is that there's going to be
a scale-free network topology.
And I was like, a scale-free
network topology? I've never
heard of that, but that's a very interesting
theory, it makes sense to me,
and I guess we'll just see how it plays
out. And hopefully
you can see, it's probably pretty faint,
but if you actually go
to any of these lightning
network explorers today,
it appears to me
that the topology that is
forming on the lightning network is in
fact scale-free, that while
there is some centrality
in certain areas
of the lightning network, that
it's fairly well distributed, and
that because more players
can join the network, leave the
network at will, that I am
not particularly concerned
about a hub-and-spoke
model actually
happening, even if we have greater enterprise
adoption. So I've
got a few video simulations
here. This first one, on the left
we've got A, B, C, and D. These are
people who are buying coffee every day. We've got
E, F, G, and H. They're selling coffee
every day. And this simulation
is showing a very simplistic network
where the value is basically moving
from the payers to the enterprises.
And thanks to
AJ Towns for creating this simulation
a few years ago. But what you end
up seeing is that all of the value
moves across the network, and then
eventually it just stops.
You get through about 30
different sets of
iterations before it blows up.
Now this simulation is doing
the same thing, but you may notice at the
bottom we've got this new entity,
this ExchangeX.
ExchangeX is not
highly
connected to many other nodes. It doesn't
even have a ton of liquidity.
But what it is doing is
providing the ability
for payers and
payees to make out
of band payments to the Exchange
in order to rebalance their channel.
So if A, B, C, or D
finds that all of the value on their
channel is on the far end and they can no
longer push any value to buy coffee,
they can actually send
out of band some fiat to the Exchange
and the Exchange will then
basically rebalance their
channel for them by pushing value over the
Lightning Network. And then vice versa
with the enterprises
E, F, G, and H. Is that when
all of the value ends up on their side
of the channel and they can't receive any more payments,
they just push some value over the Lightning
Network to the Exchange and it can pay them
out of band through some other payment
network. So
the main point to all of this
is that as soon as we
have some halfway decent
liquidity provider, you know,
enterprise level exchange that
is integrated with Lightning Network,
we can now
make the use of
these Lightning channels much more long
lived. With the previous simulation
you can only get through about 30 payments
from each consumer before they
ran out of the ability to
push more value and they would have to close the
channel and reopen it or something like that.
With this
very simple simulation
it basically becomes
unlimited.
The video itself goes for the
equivalent of three years and we just
stopped rendering it after that point because there's no point
continuing. But
this is the main point that
I'm trying to make is that having enterprises,
especially exchanges, is going
to make the use of
Lightning Network and
the reuse of long lived channels
much more feasible.
So let's go to the
next slide now. This is
from Chainalysis a few years ago
where they were looking at general activity
of addresses on the network,
basically showing that
about 150 million
of recently active addresses could
be ascribed to various
enterprises, whereas about
25 million appeared
to be maybe individual wallets.
So this is just giving you some context of
general activity on the network.
This is more recent if you're
looking at payments per day
which is basically TX
outputs per day. There's a
pretty strong case to be made
that somewhere around half of
all of the transaction outputs that are created
are in fact coming
from exchanges.
This is just from looking at the transactions
that have many outputs on them
which are
almost necessarily
either a batch payment
from an exchange or possibly
a coin join, though there aren't
a ton of coin joins happening in
comparison to exchange activity and also
not all exchanges are batching
their outputs. So it probably evens
out pretty well.
Once again, the point being that if
50% of the on-chain activity
is coming from exchanges
then getting these providers
on the Lightning Network gives us
a potentially large optimization
for reducing on-chain
block space.
This is looking at a
specific transaction that was a
Binance withdrawal. This just happened yesterday.
I pulled it up on oxt.me.
It's very easy for anyone
to go to some of these
wallet analysis
services and actually look at the transactions
that are known to be
coming from exchanges.
This particular transaction is fairly
standard. It had 40-something
outputs. Six of those
outputs were all going to BitMEX.
A handful of them
were going to Coinbase.
Another handful of them were going to HitBTC.
The main point here being
that when exchanges are doing
these large batch payments
they don't necessarily know
that maybe a lot of the outputs
in a single transaction are going
to the same place because they're just
receiving a pseudonymous Bitcoin
address and they're just batching them all together
and sending them. The reason
why the Lightning Network is so
interesting is that it can
automatically deduplicate this.
You just give a Lightning invoice
and it gets routed automatically
if there's a lot of activity
going back and forth. The Lightning
Network as a protocol
is automatically deduplicating
a lot of these back
and forth transfers. This is another
bit of analysis from BitFury
which is probably hard to read but essentially
this is from 2018
showing that there are a number
of different exchanges.
This was done at a country aggregation level
but basically showing that billions
and billions of dollars
in on-chain activity
are only going from one exchange
to another exchange.
It's just back and forth, back and forth.
And to actually hit on
that a little bit more, this is another chain analysis
diagram from a few years ago.
All of the blue
edge activity are exchanges.
Yellow are some merchant
providers and the upper left
quadrant are some darknet markets.
But once again the main thing
that I want you to take away from this
is just look at all of the activity
that's going from blue to blue, exchange
to exchange.
Traders on one exchange
may be arbitraging with another exchange.
They may just be rebalancing their risk profile.
Who knows
what the traders are actually doing
but there's just so much evidence
that shows that a ton
of our transaction activity
is between exchanges.
So imagine how much
of this redundancy you could
deduplicate if instead
the value was flowing over
something like Lightning Network.
Now Balaji Srinivasan
gave a talk back in I think 2013
where he was talking about network effects
and how we grow the network
from an economic standpoint.
I think that this is a pretty accurate chart
though it is probably missing
the exchange component to it.
Because as we're well aware
merchants and users aren't
only interacting with each other at this point
because we don't have a
fully circular
100% contained crypto
economy. I think if we ever want to
get to the point where we have a 100%
circular crypto economy
we need a stepping stone.
And that stepping stone is getting these
exchanges onboarded so that
while we're not using Bitcoin
as a unit of account, the exchanges
can still convert things to
fiat and basically be able to pay
their suppliers in
other currencies until we hopefully
eventually one day get to the point
where merchants can pay their
suppliers in crypto directly and those
suppliers can pay their employees
and other enterprise
companies that they deal with also
in crypto. So what do
enterprises actually need?
I wasn't quite sure
how well timed
this talk would be but it actually seems
to be right on the money because
if you look at your schedule you'll find
several other talks that are happening
at this conference that are specifically
focusing on some of the
needs that are going to have
to be met in order for enterprises to be
comfortable with using
lightning network technology.
So what are they going to need? Well they're
going to need really high
reliable services.
In many cases these enterprises
may be dealing with large sums
of money or in the cases
of exchanges they may be dealing with money
that is technically not even theirs.
So the risk factor,
the level of risk that
they're going to be willing to take is going to be a lot lower.
So we're going to need the ability
to run large
numbers of nodes redundantly
that can be failed over without
losing money.
Exchanges and high
volume services are going to need
much better tools to help them
manage the liquidity on these nodes
and hopefully eventually also
plug into their exchanges
and other liquidity providers so that they can
rebalance channels without even having
to think about it.
Honestly from a
standpoint of even having to deal with
channel balancing I don't think that
lightning network will ever be able to get
to mainstream level adoption
until we can
really abstract away the need
to even be worrying about that.
From a scalability standpoint
of course a lot of
these companies are going to need
to be able to add and
remove nodes as
needed so that
the load balancing
is not overwhelming
a single node causing it to slow down and crash.
You're also going to need
a much better history of
being able to query
what has happened on these nodes from
a personal note
like something that
I ran into a lot when I was at BitGo
and realized that one of the reasons
BitGo was able to amass a large number
of enterprise customers was
because the
standard software like Bitcoin Core
was not really designed
to be enterprise level
scalable software. That's fine.
It works well for what
it's trying to do but
what a lot of companies ended up
running into is they would say
we want to add Bitcoin support or we want to create
a Bitcoin based company
and they would basically
throw this problem at the developers and the
developers would spool up Bitcoin Core and start
making RPC calls to add
wallets and add accounts
and keep track of things and then they would
find once they got to like a hundred
thousand users and accounts
that Bitcoin Core would slow down to a crawl
and it would not scale very well.
This was one of the things that
BitGo as an enterprise
was able to basically
break out a lot of the different pieces
of functionality that
were commonly being used from
Bitcoin Core, break them out into a
scalable architecture
and then essentially sell access
to that to other companies so that
they could have highly performant
reliable and robust queries
that they could make to a
service to get data and to
interact with the network.
From a security standpoint
these are hot wallets
so we're going to need much better
level security than just keeping
private keys in memory on some
virtual machine.
Preferably having actual
hardware security modules that are managing
the hot keys and then having other
systems to help manage the keys that don't
necessarily have to be hot. I know Chris Stewart
is going to be talking about
some of the ways that you can approach
the private key security
with Lightning Nodes later on today
and from a business perspective
additional policy enforcement that
could perhaps also be done
at the HSM level but basically
some additional level
of assurance so that
you are fairly
confident that someone won't be able
to just make a single API call
and drain all of your Lightning wallets.
And of course boring
old accounting tools, being able
to put together history on
a per user basis and figure
out what different users balances
within your system are going to be
very important.
I think that covers most of it
but in general
this is something that I think is
going to be ongoing for the foreseeable
future and I'm hopeful
that we can get some people thinking about
these problems, building some tools
hopefully even open source tools
that can be collaboratively
built on rather than
us ending up with a system
where every enterprise has to
solve all of these problems independently
and ends up duplicating
a lot of the work across different companies
in this space.
So I hope I convinced you that
having enterprise adoption
and especially exchange adoption is
important for a Lightning network so
if you're not building these tools yourself
feel free to
badger the support cues
at your local exchange and ask
when Lightning. Thank you.
Thank you.
Thanks very much James and what a great talk
about enterprise adoption of Lightning
Network. Next up we've got
Rusty,
Rusty Russell from Blockstream.
Make me an offer, next level
invoicing.
Awesome.
Thank you.
Whoa.
Hi.
The audio is obviously working.
My name is
Rusty Russell and this is actually my official
job title at Blockstream, Code Contributor.
It's generic,
it's flexible, it's probably a little
too humble maybe, but
that is me.
Now
before we begin the main part
of this talk
I want to tell you a story.
Once upon a time
when Bitcoin
was young
there was an enterprise
called Satoshi Dice
and the happy Bitcoiners
frolicked in the blocks
and they would send their Bitcoin to Satoshi Dice
and receive either a multiple
in return or a single
Satoshi consolation
prize.
And into our happy tale come the evil
core developers who
introduced the dreaded dust limit
destroyed
the business model of
Satoshi Dice and the brave entrepreneurs
I believe who were mainly
poor orphans and adorable
puppy dogs in fact.
And I can see you looking
horrified. Rusty why are you telling me this
awful and heart rending tale?
Because
like the Bitcoin network
the lightning network will change.
It will come from this
happy place that it is now
and it will have to adapt as the
environment that we are in becomes
more adversarial.
It's going to have to develop
defenses against various forms
of behavior and spam
and so
I feel
perhaps so that
nobody's giving a talk like this about me in five
years time we should give you
some warning about things that
generally the developers agree
will happen to the network in the next
some
mumble number of years.
Now the first
is that despite what Jamison said fees
will rise and there are
two real reasons for this.
The first is that the default fees
that dominate the network today
are approximately zero
and that has proven insufficient
to maintain
robust connectivity.
We're already seeing
people increase fees
and we expect that to continue to some level
but there's a second reason
and that is that defending against
some kinds of spam on the network
requires us to introduce some
upfront fees
and the problem is
that these
upfront fees have to be large enough to
prevent spam but small enough
compared to the current
success based fees
so that we're not incentivizing failure.
Because if we start
allowing those to just steal the money
then users
will fall back on reputation systems
to figure out what nodes to route through
and as far as we can tell reputation
systems are inherently centralizing
so we want to avoid that.
So if you are relying on fees
staying around one part per million
like today
you should be thinking or rethinking
your plans for the future.
Okay.
The other thing
that will happen is
very slow payments
will have to be defended against.
Say anything that takes more than maybe
a minute or two
is going to have to
have some solution.
And that's because
really slow payments are trivial to weaponize
on the network so the network
will have to defend itself the same way the Bitcoin
network had to defend itself against dust.
And there are two obvious
ways to do this. One is to charge
a much larger upfront fee
for things that self-identify as slow payments.
And the second thing is
to aggressively close channels
when delays happen.
And there is a proposal for that
which nobody likes
but that seems to be the best thing on the table.
So if you're currently
your business model relies on
you know payments that are
taking minutes
or blocks or
days
that's fine
but make sure you have a plan B. And there are
some things in the protocol that we can do to alleviate
a lot of these things that we're doing today. And this is
what I want to emphasize. There's nothing wrong with doing any of these
things at the moment. That's fantastic.
But as a
public service announcement I do want to tell you that things
are going to have to change eventually.
So that's the end of the PSA
part of my talk. Now I'm going to
talk about what I came here to talk about.
Which is
well I'm a protocol
level person. I'm happy with bits and
bytes. And there are a whole heap of cool things
happening in the protocol that I could have talked about and
there are some amazing talks on the schedule
talking about future stuff that's coming up.
But I dug
out something that we've been talking about for a while
because for this audience
I really want your feedback on something.
So
let's
start with
I wrote Bolt 11 and
I probably am a bigger fan of
invoices than anyone you'll ever meet who's not actually
an accountant.
The oldest piece of writing that we have
is actually a Babylonian
receipt or maybe an invoice.
And the reason is that when
there's no intermediary in a transaction
an invoice or a receipt is
key to keeping
the vendor honest.
Now as we grow the Lightning Network
into something that supports real commerce
between people you don't know
and trust you will definitely thank
me that we have cryptographic
invoices. But
invoices also
suck for a whole range of use
cases that were things that we really
really want to do.
So they say that every
problem in computer science can be solved by adding
another layer of indirection and that is exactly
what I've done.
Now I do want to caution
you that I
wrote literally some of this
draft Bolt
on the plane
on the way here.
So I made arbitrary choices
some of which are
indefensible and will no doubt change.
But I want to present it to you now
so that we can tear it apart and put it back together
as something that we can live with.
So none of these decisions that I present
here as if they are carved in stone
actually really matter
and any number of them could change.
But this is what it might look like.
A lot like a Bolt 11
invoice except it starts with LNO.
You might turn it into a QR code
it gets into the payers
hands somehow.
And then
they send through the
Lightning Network itself
a request to the node
that signed the offer.
And the node replies
with the real invoice.
And from that point
the payer then pays the invoice like it normally
would. Probably but not
necessarily along the same path that it
used to request
the invoice in the first place.
Now if we break up the offer
it starts with LNO1
and
I know Roast Beef and Connor
will be really happy with this.
It's actually TLV data
inside the invoice
using our standard TLV format
not the boutique one that we use in Bolt 11.
And at the end it has a signature
from the node that it came from or maybe a node ID
and signature if we're going to be fancy and go for
like 32 byte pub keys
and Schnorr and everything else that people want these days.
And the TLV
data contains the offer itself. Now it has
some obvious things. It has
an ID so that when I ask the node
for the offer it knows which one I'm talking about.
It has a description which says
what you're offering.
Cup of coffee or
whatever it may be.
It has an expiry but unlike
Bolt 11 expiries if there's no expiry
it means it doesn't expire.
These things can stay around for a long time.
It may have some path hints.
We have these hints already in Bolt 11
and they tell you how to get
to the node if it's hard to reach or if it's through private
channels or even just a hint about
the capacity.
And also of course, oh this is new.
It has a maximum quantity. For some things
you want to offer but it makes sense
for someone to order 10 of them at once.
So we've added a
quantity optionally
to the offer. And of course
it contains an amount which is the amount
you will pay for the item
that's being offered
multiplied by the quantity if
you have one. But the amount also
contains a currency code.
That's weird.
Because it turns out that
offers can stick around for a long
time.
And generally
this currency code could be in Bitcoin
if you're a Bitcoin maximalist.
But for a lot of places
their actual underlying costs
are in a different currency so they want to reflect that
in the offer.
That's going to seem a little bit strange to you.
But it particularly
comes home when you have an offer
with recurrence.
So an offer
might be
a simple
cup of coffee. Or it might be
something that happens
every 60 seconds
that you keep paying.
Or it could be every 7 days
every month
or even every year.
And there are a lot of things
that this applies to. That you want
in this recurrence.
It could also have a limited number. It could be 6 easy payments.
It could be
something that is naturally
limited to 12 or something.
It could also have a base time.
Sometimes you pay and then you pay again
in 60 seconds. Sometimes
you pay on the first of the month and you pay
every month.
If you specify a base time that anchors where
that payment occurs. And there may be a pay
window. Perhaps you have to pay within the first 3 days
of the month. And there's a special value
here that says maybe if you pay half way through
the month you only pay half. You pay
proportion to the remaining amount
in that period.
I didn't go all out
on this. You cannot say
I want you to pay me on the first Tuesday
of the month. Or the last weekend of the month.
But this seems to offer
enough flexibility for the moment at least.
With the minimum intersection of
complexity.
Now we also have
additional data.
You may also say, and I also want you to send me
a delivery address. For some things that makes perfect
sense. You're ordering something, I've got to send it to you.
I want you to specify a delivery
address. Maybe a telephone number
if it's like a
credit for example.
Like BitRefill doing phone
credit. It could be like
a voucher code. This conference
had a voucher code. A lot of places have a voucher code field.
If you supply a voucher code, perhaps
that gives you a discount. Invoice.
And this, we can add additional ones
because this uses our standard bit encoding
to say what you need.
And the lightning protocol at the low level
has this rule that says it's okay to be odd.
And that
means that if you don't understand something and it's
odd, that's okay. You can ignore it.
But if you don't understand something and it's even, that means
you're in trouble. You need to go upgrade or something.
Now this also provides
unsolicited payments. Sometimes called
donations.
If an offer has a zero or empty
offer ID, that's special.
That means I haven't actually seen an offer. I just want to give you money.
Now this message, when we
request an invoice, is
onion encrypted like a normal HTLC payment
through the lightning network. So no one can tell
where it's going, etc.
And it contains the offer ID that says
here's the offer I'm asking for.
And it contains a nonce,
a pub key
that the payer chooses.
And of course the quantity and
amount, if it was a straight donation.
The recurrence number, if it's one of a
series. The delivery info and stuff
like that, if that's something that's required.
And then the invoice reply message could be an error message.
Like I don't know what offer that is
or that's actually expired. What are you doing?
Or something like that. It could be a
replacement offer. Oh sorry, that's expired, but here's
a new one. And that has to be signed
by the key in the original.
So if
FoodCorp buys out BarCorp and you use
a FoodCorp invoice, it might
be replaced by a BarCorp invoice
for the same thing, but it has to
be signed by the original FoodCorp.
But normally the reply will just be the invoice,
right? That's how it's supposed to work.
And invoices
as of like two
weeks ago or something, have an S field,
a secret field
that you're supposed to send through with the payment
that proves that you
saw the invoice. Now
in the case of an invoice
that we've requested, the secret
is actually a Merkle tree
of the
invoice request.
And you basically
take the tag that they provide in the invoice request
and you build up a Merkle tree like this.
First you make sure it's a power of two
and then you shaw everything
and then you sort them by the shaws
and then you do the Merkle thing and you end up
with a single secret.
And for those of you who
completely didn't follow that,
this gives you the ability
to prove to third parties various
things about the invoice and thus
the payment.
I can prove any part of the delivery info.
I can prove that I
paid this and
I had it shipped to Australia.
Or I had it shipped to
my postal code without revealing
anything else about the payment. I can prove
to you that they screwed me over
because they didn't deliver it and here's the
proof that I ordered it here.
You can also prove that you are
the one who paid for it.
Or at least you are the one who requested
that specific invoice
because
it has that transient
key in it that we sent as part of
the invoice request. And I can prove
to you what that key is and I can
prove to you that I control the key by producing
a signature.
Now, that's
pretty cool,
right? An offeror says
cool, ask me for an invoice.
And you can request it over Lightning.
But also, sometimes
you just want the invoice
request. I want to tell you, give me an
invoice please.
And so we come up
with another encoding, LNI,
where you say
cool. It's basically an invoice
request that we'd normally send over the Lightning network except
in
encoded form.
And it looks the same but it also has a description
that says what you're supposed to invoice me
for. This is the use case
of, I don't
know, an exchange withdrawal, for example.
It would push this LNI
thing through to you, maybe as a barcode, maybe
through your browser, to say
give me an invoice so I can pay you.
And it would say what the payment's for.
It may have some paths on how to reach
them. It'll have the
amount.
But most importantly, this can be
used for refunds.
Right?
I want the user to present
me with an invoice so I can pay them a refund.
Because remember, the
invoice secret commits
to the payer key
that they gave me originally, that transient
key that they gave me. So they
can use that to prove that they are
the ones who paid and that they are the ones who are entitled
to the refund.
And one of the problems with refunds
generally, or any kind of reverse
flow, is that in Lightning
you generally know who you're
paying but they don't know where the payment's coming
from. And if you tell them to pay you,
you're telling them who you are.
Or at least your node ID.
But we have another proposal coming
which is rendezvous routing, and that
preserves recipient privacy.
So when you combine these technologies, you
can get your refund
without actually revealing
what node you are on the network.
So,
what do offers give us?
They give us static
invoices. An offer is a static invoice.
You can print out these QR codes and you can slap them on
things, and somebody can come along and scan them
and pay that way.
You can slap it on your website
because in order
to securely use a Bolt 11
invoice, you have to generate a fresh
one for every payment.
And not reuse them.
And,
ideally, a Bolt 11 invoice
should have the description that is specific
enough to identify that particular
payment. Not just a cup of coffee
but a cup of coffee that I
delivered at this time to this person.
At this address or whatever.
Because otherwise
I can prove that I paid for a cup of coffee
but I can't prove anything
useful about it. Sure, we delivered a cup of coffee.
Well, that wasn't my coffee.
How do you know?
But this gives you static
invoices. It really does.
It gives you user controlled recurring
payments. Vendors love recurring
payments with credit cards. They love them, right?
They want you to sign up for free trial periods so they can put you
on the recurring payments. Recurring
payments, when it's a pool model like
that, are evil, and that's pretty clear.
Because it's incredibly painful to
cancel them. User controlled
recurring payments, however,
bring back some of that
what's the phrase I'm looking for
sovereignty
over your payments. You
control your recurring payments.
You flip across the tab in your wallet
and there you can see all your recurring payments
and just cancel them. Done.
Because you're the one pushing them out every
60 seconds or every month or whatever
the schedule is. And you're the one who agreed
to that. And that's
incredibly important. And it's useful.
I mean, I have no problem with recurring payments for some
things as long as I consent to them and I can
cancel them at any time.
It gives you spontaneous
donations with a
receipt.
At the moment there are various
hacks that you can use to pay a node
but you
don't have any evidence that you actually paid it or that they actually
got it.
Or the amount.
If you have like an invoice without an amount
there's no evidence that you actually
paid that amount, right? You can have an invoice
that doesn't specify an amount and will accept anything
but then you have no way to prove that you gave them
more than one Satoshi or technically
more than one millisatoshi.
So this gives you spontaneous
donations with a
receipt. And of course
it allows full or partial refunds.
Which is pretty cool
as well.
So my question particularly
to this crowd here
is this
useful? Is this something that you want?
What can't
this do? Are there other things, plans that
you have, things that you're building
that would be really great to do that this doesn't
quite make it?
Then please come and talk to me or send
an email or join the discussion so
that we can make sure that we have as much
coverage as possible of these ideas.
Because I kind of want to
throw myself forward a little bit
and look at the future
and what I might like to see
with this kind of model,
right?
So
somehow, could be on a billboard,
could be on an ad, could be pushed through to my
browsers, whatever, I see
this offer for like a weekly delivery of coffee beans.
And it's at 2 euros per
100 grams. Except
my wallet doesn't show me that. It shows me
in Australian dollars
3 dollars 50 per 100 grams
weekly. How many do I want?
Cool, that
looks like a great deal. I'll do that.
I order
10 of them, 1 kilo.
My wallet says they want a delivery address. I select
my work delivery address.
Underneath
my wallet is now, use that information.
It's got approval from me to spend this money.
It goes out, it fetches the real
invoice, and it comes back.
And they've modified the
description. Description no longer says
weekly coffee beans, it now says weekly coffee beans
plus postage.
And so now it says they added plus postage
and they also changed the amount from what we expected.
Of course the amounts are actually in Bitcoin.
And it said, oh by the way, they've
charged an extra 20 Australian dollars because postage to
Australia is really expensive. And at that point I either go
no cancel that, I'm going to have it delivered to my remailer,
or I go I really want that coffee
and I hit yes.
Go, done.
And of course if everything had come back
within the
parameters that it had originally offered me,
it wouldn't have prompted me again to say, oh by the way,
the deal changed.
Now what's cool is I've signed up for this once a week.
So next week it automatically
goes back and just re-requests
uses the offer, requests
the new invoice.
And remember it's
already got approval from me to spend this money.
$35
in this case, in Australian dollars.
And so internally it does the conversion. And if the price
is within say 5%, it doesn't bother reprompting
me. But if the price has changed, it looks at the Bitcoin
amount that's in the invoice
and it's moved too much, it'll reprompt
me and say, hold on, the deal has changed.
Now it knows from
the original offer that the thing was in euros. So it may
be able to tell me, well okay, so the euro has moved
and that's probably why.
Or it could just be we're using different price bases
for how much Bitcoin is worth.
Or it could be they're trying to screw me.
And at that point it will stop
and go, hold on, the price has gone up. If the price
goes down I probably don't care.
And it will require re-approval. But normally
it will just continue.
And this emphasizes two things.
Firstly,
I want
my wallet to be my agent to deal with this stuff.
Right?
I want it to check with me and get approval, but once it's got
approval I want it to just go and do it.
But
the other thing is that
when I want to buy coffee
or whatever it is that I'm after, I do not
want to go to your website. I do not want to click
around and I do not want to find the thing and I do not
want to subscribe to your newsletter and I do not want to
create an account. I just want
you to shut up and take my money.
And in theory,
this kind of flow
allows exactly that
to happen.
I don't want to scan or get pushed
the thing, hit yes
wallet please do that
and we're done. We don't have a
relationship. I've just
bought something from you.
And that is what I would like to see.
So
I've deliberately left room for
questions.
So do we have
any questions about offers?
There's a microphone here.
Can you stick your hand up?
Yes. Thanks for the talk.
I want to be sure that I understood how this works.
So basically
you request an invoice
and then you generate an
invoice with a refund
in order to generate
like a genetic invoice every single
time and then do not need to
receive the specific
specifications for
every payment, right?
So if you're trying to offer someone a refund for something?
Okay.
Is the process of
paying with our invoice generating a
genetic invoice that could be generated
anytime?
Okay. So let's look at the way
it happens at the moment. If someone wants to offer you a refund over the Lightning Network,
they say send me
an invoice so I can pay you.
And they say it in words like over Twitter
or email or whatever.
And then you generate an invoice
and make sure you get the amount right
and who you invoice it to and all those things.
I just want to automate that flow.
So there will be a standard message that says generate me an invoice
for this. And your wallet will generate an invoice.
Or it will say to you, hey, they want me to generate an invoice.
Are you okay with that? You say yes.
And then it will send the invoice to them
and then they will pay it.
So I just simply want to automate that flow that is currently done manually.
And is of course very
prone to mistakes because I'm in a different time zone
and the invoice default timeout
is going to be one hour.
And by the time they woke up,
the invoice had expired and they could no longer
send me my refund. All that kind of crap goes away
if we automate the refund flow.
And it makes sense if we've got this mechanism
to communicate and ask for invoices
through the Lightning Network,
we can also repurpose it to do this
refund flow.
I hope that answers.
Do we have any other questions?
So there are
two things.
First, I
recently
made an issue on LN URL repository
about
doing pretty much similar thing.
You thought it
much more true about
these various scenarios,
but about automation of workforce.
So maybe
it seems like your idea to
do it in both
directly may be better.
Especially because it has built
on routing, so you can
protect privacy. And another idea
that I had before
is to
also categorize
the fields that you are selling.
So if you have a supermarket,
you probably already have some kind of
system that categorizes
whether this is food,
this is, I don't know,
some tools
and so on. And then
your wallet could make you reports
on how you are spending your money
without
you having to
fill it manually and without
screwing your privacy. Because
for instance, my bank offers me
this possibility to have
nice charts and whatever.
I was amazed, but at the same time
horrified that, oh hell,
this is what they know about
me. So this would
be really cool to not
have to get rid of privacy or comfort.
That is something I hadn't thought about at all,
for example, which is great. This is exactly why I'm here
to present, to throw this out here.
Categorization would be
definitely something that would be useful.
And we just have to come up
with a spec for it. Now to be fair,
I was without my notes here,
but I did forget to credit
LNURL, who have done a lot of experimentation
in this space. And I love what
they've done with invoice requests
and stuff like that. And building those layers on top,
I just want more.
I want more of that.
And so,
I forgot to mention them, but
the LNURL spec is
kind of a grab bag of things that you need
to bring lightning up a level. And I'm like,
we want that. And we want to end at the bolt level.
I think having individual implementations
do it is cool for experimentation.
And eventually I have to implement this
and see lightning. But the important thing
is that we get it spec'd out. We get a whole
device on it. We get a whole group of people to play with it.
We get commonalities
so that everyone can use it.
So I really do think addressing it at the standards
level is the way to go. Cool.
Do we, how are we going for time?
We have like 90 seconds.
Do we have one final question?
Yeah, so you said something
about payment secrets with Merkle
root, I guess.
How, okay, so I know
that there are like overpay attacks, where if someone
overpays, you can intercept the payment and
steal fees, I guess.
Like with donation invoices, you can steal all the money.
How does the secret actually
get to the recipient
so that they can like verify it, I guess?
Right, okay, so
the secret actually is sent
through with the embedded in the onion
at the moment. So, or at least
in the spec that we
agreed on yesterday, but I haven't edited the spec
yet to make the changes. But yeah,
we will be tumbling that through the onion packet.
So it will come along with the
payment itself will come the secret.
At the moment it's a random
nonce, but with this proposal
it will actually in that case be a full Merkle tree.
So you'll be able to prove things about it.
Okay, well, I think we are
done.
On time.
Thanks very much, Rusty.
So, Dez,
just how good is lightning?
Lightning is amazing.
Well, our next speaker
is talking about how much better could lightning be.
It's Fabrice from Async.
Yeah. Welcome.
Okay, right, good morning.
So the talk is going to be
how much better lightning could
be, and especially from a UX point
of view. So
I will also start with a story.
Suppose
you travel back in time and it's
four or five years ago and you want to
introduce people to Bitcoin. So what do you do?
You could start explaining
how Bitcoin works and
cryptocurrency and everything and it's
complex. And
one of the really nice things you could
do at the time was, okay,
if you want to show what Bitcoin is and how it
works, you just
you get people to install a
wallet, anyone, and
you send them a few Bitcoins.
And they can see that, okay, they've received
something, it really shows them
how it works, even if they don't really understand
the workings of it. And
you ask them to send it back to you.
And it's a
very cool way of introducing
people to Bitcoin, even if
they don't understand and don't want
to understand the technical
issues of Bitcoin.
And if you start
eventually you have to start
about how do I save my funds?
How do I backup my funds? And it's
very easy. You have
12 words, just write them down,
store them safely, and
it's all you need, basically.
You can introduce people to Bitcoin
in just a few minutes and
a lot of things do a demo
and it's very fluid.
It takes a few minutes
and you could do it on stage. People did
it on stage a few years ago.
You have to trust the network
and the wallets and everything, but it's
going to be a good demo.
So now
five years later, how do you
demo Lightning?
You ask people to
install a Lightning wallet.
You send them Bitcoin.
And
you tell them you need to open a channel.
But if people don't really know about Bitcoin
or Lightning, it's a bit tricky.
What's a channel? How do
I open a channel?
Where do I go?
They open a channel and they say,
can I use it now? And you say, no.
You have to wait until it's confirmed.
And there goes your live demo. You can't do this
live on stage because it's going to take
at least 30 minutes or
maybe even more.
And they send you money over
Lightning. And this is really
awesome because it's
instant, cheap micro payments and
there's really a wow effect.
But they can't send it
back to you because
they need inbound liquidity
first. And it's a bit
tricky to explain.
Basically, you tell them you need
someone to open a channel back to you.
And I do that in practice.
And if you start
talking about backups, very quickly it becomes
a bit hard because backups
in Lightning, and I guess everyone
knows that, is tricky to get
right. Just a static backup
of your seed is not enough.
You need dynamic information. And if
you're late, or if you lose
information, you could lose money.
So in a nutshell,
there are UX problems
with Lightning.
So this is a
copy of a very old
slide about NoSQL
databases 10 years ago
when NoSQL databases were all
the rage and new developers were saying
NoSQL is so
much better than relational databases.
And more
experienced people were saying no, they're not.
And no one was
listening to them. It's a bit like
altcoins two years ago
when everyone was kind of left and right with new
altcoins with a dark base, blah, blah, blah,
shared something so much better than Bitcoin
and everyone was saying no, it's not.
And no one was listening.
It's the same story. So
can we have the same simple
fluid UX we
have with Bitcoin and keep
the Lightning awesomeness? How much can we improve
Lightning and what does it mean?
Where is the friction? Is it in the protocol?
Is it in the upper layers
implementations? What can we do?
And a lot of UX
issues with Lightning
are linked to how the protocol
is designed. So
right now
the channels are single-funded.
It means all the money when you open
the channel is on one side. So you can send
but you cannot receive. There's work
on this but that's how
you set up
channels for the moment.
There's a concept of penalty
actions. This is how you make sure that
only the last
state of your Lightning wallet can be used.
So
it's
good because it punishes
people who try to use old states.
But it makes backups really tricky
because if you are trying to restore
an old backup, you may lose
money and
as far as I know, most
cheating attempts that have been detected
on the Lightning network were not people actually trying to cheat.
They were people who messed up with their backups
and used old ones and got
punished.
It also
means that you need to have, if you can't
watch your channels yourself and detect
cheating attempts, you have to
delegate these watching to watch
towers and they are hard to implement
because right now
you need to store an ever-growing amount of data.
Basically you need to store
new data every time the state changes
and it's really
hard to have good incentives
for that.
The payments are hash-based
today. Basically you pay
against the preimage of a hash.
It works very well and
it's enforceable with the Bitcoin
scripts we have today but it's really hard to
fancy things with that
because you can't combine pre-images
and get the same combination
in hash obviously. If we were to
use points and secret keys
or synergies, we could do more interesting
stuff but it's not possible yet.
There's also
source routing.
The way Lightning works today, the
sender creates the route. The sender
has to decide
where the payment
will go through, which means
it's good for privacy but it also means
that to send a payment
you need to have a good enough view
of the network
which could be a problem
if you're offline most of the time
and mobile wallets will be offline
most of the time.
If you start
your mobile wallet
you need to partially
synchronize your view of the network. If it's
not up to date, you may not find the route
or you may try to read payments with wrong
information and it will fail.
Some of these issues
are not really linked to the protocol
but more to the way it's been deployed
so far. There are capacity issues
if you want to pay for something that is a bit expensive
it may fail today
because channels are small. This is something that
will improve over time and there's a nice
solution which is
AMP, which is you split payments
in small shards and you pay
and you aggregate
these payments at the destination.
And there are
reliability issues. So this also
is something that is getting much better. The network
is much more reliable than it was one
year ago. But there are still issues
and this could be improved
I think Wesley mentioned it a few
minutes ago. You could start probing
more aggressively to detect faulty
nodes and you will start
soon banning peers and nodes
that are not reliable.
And there are issues
that could or should be
hidden from users. Like
how do you present
a unified payment experience?
How do you present a unified balance?
Do users really need to know
what is on-chain, what is off-chain?
Do they need to
know about channels and channel
management? But for this
there is no yet
a generic solution. You
have to make trade-offs. You have
to make choices. In bound
liquidity means, for example
you need to lock funds.
Zerocon channel,
turbo channel, it means that someone has to
take changes because if the funding
transaction doesn't confirm your channel
is gone, if it's been used, well maybe
someone is losing money. So you need to
make trade-offs.
And many of
these UX improvements will require
protocol level changes.
For example, AMP,
atomic multipath payments,
tripling, which is a way of
adding some packet
switching back into the way routing
is done on Lightning, switching
from pre-image hash
base to signature or
secret key points verification for
payments. So this
will take time. But there are also ways
to extend Lightning
with custom features.
It's always
been possible the way the protocol
was designed, but it was a bit
ugly and clumsy.
And it's much better now. And basically
if two nodes agree
on a set of custom features,
they can start using them. It has no impact
on the rest of the network.
As long as you comply with basic
Lightning rules and
now that the protocol has been
modified to include support for TLV
and other stuff,
it's much cleaner to
add custom extensions
to the
Lightning protocol. And this is what we did
for our UX experiments.
So yesterday we
did a video of our new
wallet, which we call
Phoenix. And it's
not just an experiment. It's something we
intend to ship within a few weeks
in actual product.
But basically we wanted to see how
much we could change
Lightning UX without
having to make really bad
trade-off, without having to
require trust in us, without
having to become custodial.
And what is the friction with the current
protocol? What we can change
just
on the application side and what needs to
be changed at the protocol level.
So
we've been developing
two different products
for more than two years now. We have a
wallet, Eclair Mobile.
Is anyone using Eclair Mobile?
Yeah, good. Good on you. Thank you.
And
it's an actual
Lightning node. It's not a
custodial node. It's not a remote control for
something that runs in a cloud or
at home. It's an actual
Lightning node. It's widely
used and it doesn't try
to hide anything about
how Lightning works. You need to
know about off-chain and on-chain
balance. You need to open channels
manually. You need to take care of your channels.
You can set custom fees
for your closing transactions.
So
it's highly technical. It's really
good. I really like it. But
a lot of the
feedback we got from users
of Eclair is
why do I need to worry about what is on-chain
and what is off-chain?
The UX is a bit
technical. And we also run
a big
nodes on Lightning. So we see a lot of
we relay a lot of
payments. And
so we also get feedback from users
when payments fails or when they have issues
with capacity. And since it's really
hard to know where the problem
comes from in
Lightning, it's really hard to diagnose
which nodes
didn't do its job the way
Lightning is designed today. Very often,
whenever there's a problem, people ask us
what's wrong? Because
they don't know. They don't know.
So we get feedback
from users
and all they know is they couldn't set a payment.
So we got lots of feedbacks
on UX and the problems that
users actually see when trying to use
Lightning.
So the pain points
with Lightning is
first, it's onboarding.
How do I open channels
when I don't have Bitcoins?
Why do I need to wait?
I haven't complained.
The complexity of the old
Lightning UX.
On-chain, off-chain.
Do users really need to know that some of their
phones are on-chain, some are
off-chain? And if you start explaining
OK, you need to know because that's how
Lightning works. And maybe
you're looking at the
wrong target. People really shouldn't
know about this.
Channel management. Why do people
need to manage their channels
manually? What other
things you can do to automate the process of opening
channels without making
bad trade-offs?
And another issue is stuck payments.
We don't have a fix
for this, but basically if you try
to place something on Lightning and your payment is
stuck, you can't retry because
your payment may eventually
get unstuck.
So you may
take a chance of paying for things twice
or several times. And there's an issue
with backups. It's an issue, I guess,
with every Lightning wallet today.
Backups are hard to get right.
Some users don't really understand
why you see it is not enough to
restore your channels.
And it's something that could be
improved.
So working within
the limits of the current Lightning protocol,
how can we get instant channels?
Instant as in you can send
and receive money within
a few minutes when you start using
your wallet.
How can I display a unified
on-chain, off-chain balance?
How can I have a unified payment experience?
I want to pay with Bitcoin.
I don't care if it's Lightning or on-chain.
And how do you have simple
transparent backups where
you see it is enough to
restore everything, including
live channels?
And so
what we did is
Lightning is very
different from Bitcoin because there's no global
consensus. It's a
routing protocol, which means
the dialogue that takes
place between two peers
is not seen by the others and has
no impact on the rest of the network.
And as I mentioned,
there's some room for extensions
today in Lightning messages. You can
add fields
that can be ignored by those
that don't understand them.
And there are existing fields in some
of the Lightning messages, for example,
in the
Onion or in the
payment request that you can use for
other things. For example, last year we did
a demo of offline
Lightning vending machines
where the vending machine is not connected
to the Internet, and yet it can still
understand that you've
paid with Lightning and it can
give you the goods you paid for by
tricking something inside one of these
Lightning messages. So there
are things you can do with
the protocol today with extensions
that you can
decide to have always on
and will just be ignored by peers who
don't understand them. Or you can decide,
OK, with this specific peer, I will
negotiate extra features that are
not really part of the protocol, but
are piggybacked on existing Lightning
messages.
So what we did with Phoenix
is we created
zero-conf channels, tribal channels,
the channels you can use as soon as
they're created, so which means
there's a slice,
there's a window where
there's a risk that
the channel can be double
spent, so there's a small risk.
We have
on-demand channels. Basically, you can
route to a channel that doesn't
exist. If you start Phoenix
and if you want to receive funds,
you don't have anything, you don't have channels, you don't have funds,
you display an actual Lightning
payment request, exactly the one that
was displayed by Ressie a few minutes ago.
It's a real payment request.
It has not been tweaked. Any
Lightning wallet can pay it, but
when the last node sees that
request, it knows that the
channel ID is not an actual channel ID.
It's a hint to
create an on-demand new
channel. So what we do is
when we, before we
forward the last packet, we create
the channel on-demand and then we
forward the payments and the
payment is sent back. So it's a way of
creating channels on the fly and routing
to things that don't exist yet on the network.
And it gives you instantly
usable channels in both directions. You can
send and you can receive.
What we also did was
to use the
Lightning messages to carry
backups. Basically, you add
extensions to
Lightning messages and the
extensions is an encrypted blog
that is your channel backup.
And when you connect to your period,
you get it back from them, which means
you don't have to rely on
local storage or Google Drive.
You should because you still need to
take out your own backups. But if you lose
everything, you can still
restore your channels.
Obviously, then you need to trust
the peer you were connected to to send you the
encrypted backup back. But it's
a way of restoring live channels
even if you've lost absolutely everything.
So there are
trade-offs
we made for Zilocom channels.
It works because you're connected
to our node.
The way it works is we'll display
your
wallet will display a
payment request. We'll understand that
it's for something that doesn't exist yet.
We'll create the channel on demand
and then you can
use it in both directions.
For the unified
payment UX, we use swaps.
Swaps is trading a
Bitcoin on-chain transaction for lightning
payments by using the same hash
and preimage in both
the lightning transaction and the Bitcoin
transaction. So we do
swaps in and out.
There is currently a level of trust
you have to have in us.
This is something that is going to be
removed before we release the app.
Today, one of the limitations
of the demo, which is why it's not released,
there are things that are trusted, but
it's going away.
And the backups.
Everyone has the same idea
at different times. How do I
use lightning to create backups?
It's what I say. We use extensions to specific
lightning messages
that
will get you your backup
back from your peer encrypted. You decrypt
it, you restore it, and you're back where you
were before. You lose your
payment history, though, because this is not something you
can save, but you still get
your live channels back.
There's also something else I mentioned that
to pay on lightning, you need to have a good enough view
of the network.
It's not true anymore because
there's
an extension to the protocol
that is being specced right now. It's called
Trampoline, where basically you can
delegate parts of the pathfinding
to a node without losing privacy.
Right now, it is still trustless because
with the only Trampoline node,
obviously with the first and last node
on the route, but as soon as
other Trampoline nodes are deployed,
the privacy issue will go away, and this is
really a nice improvement on how to
find paths on
lightning for mobile
wallets or light wallets offline most
of the time.
We won't have time
for questions, so
the
conclusion for this is a lot
can be done to improve lightning UX.
A lot can be done,
but it requires some protocol level
changes. All cannot be implemented just
at the application level. We need to change things
at the protocol level, but this can be
done without having to use non-construal
wallets, and it's very important because
if we give up on
non-construal at the protocol level,
we're not going to get it back.
Likewise, if we give up
on being able to deploy
light mobile wallets at the protocol
level, it's not coming back later, which is why
we pushed really hard for changes
in the protocol that make it
possible to run nodes on a mobile wallet.
Just one last word about
Custodial Wallets.
It's much easier to develop
Custodial Wallets. Basically, it's just an API.
You don't have to deal with all the tricks we had to
implement, but
there are limitations
to what you can do with Custodial. The first one is
eventually,
if it works, and if it's widely used,
and this is what we all want for Bitcoin
and Lightning, you're going to
have KYC regulation issues.
You will not be able to run largely
used Custodial services without having
to deal with KYC, and we don't want to deal with
KYC. The second one is
in the long run, we need to be
able to offer non-Custodial services.
If it turns out that most
services are Custodial, then there's
a problem for the value proposition of Bitcoin,
which is not that.
So we need to work really hard
on making these kind of things possible
with non-Custodial Wallets, even
though they bring
a really good UX, they're easy to use,
and since Lightning
and Bitcoin are open protocols, a
Custodial Wallet can send to any Bitcoin address
or pay any Lightning
service. There are
ways to get users to
onboard, but we also need
to look at other solutions, which is why
we didn't want to go
the Custodial route way.
Thank you very much. Thank you, Fabrice.
That was wonderful.
Thank you.
All right.
All right.
Hello everyone. My name is Connor Fromnick.
I'm the Head of Cryptographic Engineering here at Lightning Labs.
I'm pretty excited to be back today, because I think
last June, a little over a year ago,
So we were here in Berlin at the Lightning Hack Day.
And I think it was the first Lightning Hack Day, actually.
And a bunch of the team was here.
And we talked about three sort of interesting directions
for the Lightning Network.
And I think they were Watchtowers, AMP, and Splicing.
Since then, we've kind of deployed
Watchtowers, like an initial version of that on the network.
So that's pretty exciting.
And to be here a year later and making tons of progress
in terms of the spec and sort of proofs
the concept of multi-path payments in AMP
is pretty exciting.
So today, we're going to explore kind of like the multi-path
payment things coming to Lightning
and sort of how that's progressed
in terms of the spec, where we are in terms of implementing
it, maybe sort of like a rough deployment timeline.
And yeah, let's dive right in.
So to address sort of the problem
that multi-path payments solve, let's say we have this network.
We have Alex trying to pay full through Brian, Carla,
Desiree, and Elizabeth.
And currently today, when you want to make a payment,
your payment is tied to one HTLC.
This is sort of the only payment type
we have today in the Lightning Network.
You get one HTLC.
You send it to the recipient.
If they have an invoice, they send you back the preimage
if the amounts match.
Now, Alex is able to send along this top route three BTC.
And along the bottom route, he can send five.
The reason that is because those first channels that
are connected to him are sort of the minimum amount
along those paths.
And that sort of caps the maximum amount of capacity
or the max payment size he can send in that direction.
And this presents a couple of issues,
especially in terms of UX.
So for Alex, his maximum amount that he can send
is the maximum size of the channel
that he has connected to him, which in his case was five.
Sort of like on the flip side, you
have the maximum receiving capacity
is the maximum sort of inbound capacity you have.
So for Fold's node on the right on the previous slide,
that was eight on that bottom path.
And that's kind of confusing for a lot of people
because you'd think that if I just have a Lightning app
and it shows a Lightning balance, that would be like,
if I have $2,000 in my bank account,
I should be able to send $2,000.
Not so with today's Lightning.
And that's because you're sort of limited this path constraint.
We get this question a lot on Slack.
It's like, I have three channels with one Bitcoin.
Why can't I send two?
And that kind of leaves users like this.
And so what is it that we want?
We want people to have this sort of idea
in terms of a better user experience
that I have a balance and that is the amount I can send.
And similarly, if I have all this inbound capacity,
that's how much I can receive.
So we want to bump up these limits.
So today, we are limited by sort of these max local and remote
balances of a single channel that you own.
We want this to be more of like, I
want to be bound by the sum of all the local or remote
capacities that I have.
So it's a similar case for the remote.
And what this leads to is more of a unified Lightning
balance, like I said, both for sender and receiver.
And to me, this is pretty exciting
because in addressing this problem,
I think it will be sort of one of the biggest UX improvements
from a protocol perspective that's
on the near-term horizon that we're working on in Lightning.
So to go back to our diagram, how do we fix this problem?
Alex is able to send three along the top path
and five along the bottom.
And what we want to do is be able to take sort of all
of his available capacity along every path all the way to fold.
The problem here, for those who are familiar with more
of the computer science stuff, is
that the max flow through this graph from Alex, who's
the source, to fold, who's the sink,
is that when you only take one path,
there are many, many other paths that
can also add additional capacity that you
aren't taking advantage of.
And so what we want to do is be able to say,
Alex could send both three along the top and five
along the bottom at the same time in one single payment.
So that is sort of where we came up
with this idea of a multi-path payment.
What if I can make multiple HTLCs for the same payment
that then are all sort of one logical payment
and settle as if they were all sent along,
let's say, a single path?
So that kind of brings us to where we are today.
There are many, many different types of multi-path payments.
I think we first kind of proposed the idea
back February 2018.
And since then, there's probably five or six
different flavors, if you will, of multi-path payments.
The first one is kind of like, oh, my acronyms
might be a little bit different from what you see on mailing
lists and stuff like that.
So the first one is multi-path payments,
is what I'm going to call it, which is also
referred to as base AMP.
There's a proposal for this on the spec right now.
This is more or less kind of the most logical next step
from single-shot payments.
It uses, in the same way that a regular payment,
you get an invoice from the receiver.
It has a payment hash.
I make a payment to that payment hash
and then receive a preimage.
This is sort of the direct translation where you just say,
I send nHTLCs, and then the receiver kind of
waits until they all get there.
And once it has enough that settles the invoice,
they send a preimage back along all those paths.
So that's, like I said, the most direct.
All the UX metaphors that people have developed
around proofs of payment or whatever, those all
carry over to the style of multi-path payments.
The next one is what we call atomic multi-path payments,
or AMP.
And that is sort of really a bigger departure
from this MPP or multi-path payments.
The main reason being that you don't actually
get a preimage back.
There's sort of this concept of, oh, I paid.
I got the preimage.
That means I paid.
In this variant, that's not the case.
What happens is the sender is actually
generating all the randomness for preimages
and hashes for all the HTLCs that it sends out.
If the receiver gets payments that sum up
to the total of whatever invoice they have,
then they will just settle.
But the sender learns nothing new
because they generated all the randomness.
And this is done the way that you
get n of these payments with different payment hashes
to be sort of one unit is we use this additive secret sharing
technique, where once all the payments have arrived,
the receiver has enough information
to actually sort of reconstruct the preimages
and send them back.
And I'll get more to that later.
And then a final kind of flavor that I
won't talk about as much today is
the sort of discrete log multi-path payments.
These will kind of come around more
once we have Schnorr widely deployed.
You can technically do them today using 2P ECDSA channels
or any sort of those threshold or multi-sig ECDSA.
But this is sort of after a world where we've
replaced payment hashes with elliptic curve points.
And you're actually sort of making a payment
to a public key.
And you eventually learn some secret.
These are probably the cool, it's
undeniably the coolest form of multi-path payments
that you kind of know of today.
But they're kind of a little farther off.
So we're going to spend more time
on the first two, which are more realistic in terms
of a future timeline.
So the cool thing about the discrete log multi-path
payments is that you can kind of take the best of both worlds
from the regular multi-path payments and the atomic ones.
And that is because the atomic multi-path payments,
all the HTLCs are different hashes.
So it offers more privacy because you
can't correlate that these different HTLCs are
for the same payment.
And you can do that here.
And in fact, even an additional step beyond that
is that each hop actually sees a different random public key
or hash, let's say.
So then you can't even tell if you go in a cycle
that they're the same payment.
You can optionally do this sort of pre-image reveal technique.
So like I said, in the multi-path payment,
you actually get a pre-image back,
sort of like how Lightning Payments work today.
But the atomic multi-path, you don't,
because the sender already knows it.
In this discrete log case, you can actually do either one.
You can either choose not to, or you
can have the sender reveal this private key in the process.
So it's a lot more composable when
it comes to integrating this with other, maybe more.
There's a lot of other composability
you can do with Lightning Payments like on-chain HTLCs, loop,
those variants.
And this is all enabled by this sort of additive, homomorphic,
secret sharing, which if you're interested in this,
I would highly suggest reading the atomic multi-hoplox paper
that Pedro has been presenting over the last year or so.
So let's do a quick dive into how these things work.
So for those of you unfamiliar with all three
applications this year deployed, what
we call this TLV library or serialization format.
And that enables, it's kind of like a key value
dictionary that can be serialized efficiently.
And we kind of use that to add extensibility
to all of our wire messages, onion payloads,
stuff like that.
So we're going to add a new sort of MPP field for the final hop.
And when I send out multiple HTLCs
for this multi-path payment, I'm going
to include the exact same one of these fields in all
the payloads to the recipient.
These fields have two things in them, the total amount
of the sum of all the HTLCs I'm sending out,
and then this payment address, which
is more or less just to prevent other people from trying
to collide with your payment, since there are multiple.
It's just like a random identifier that keeps them,
like the receiver can basically like
unsort them if people try to collide with your payments.
But the thing you want to worry about
is the total amount, because that, once I send out
any HTLCs, the receiver gets them and waits
until he has what is claimed in all those payloads,
and then he settles them as one.
On the right, you can see sort of like some simple logic
for basically optionally including that payload
into the final hops onion.
And like I said, the receiver waits
until he has a set of HTLCs that actually add up
to the total amount.
And that total amount will be the value
that's in the invoice.
So just like before, if I make a payment in the single shot
case and the amount is too low for the invoice request,
you could reject that payment.
In this case, if the total IMsat is too low,
you would just reject all the HTLCs.
But if it matches, you'll wait until they all arrive.
And again, the sender will actually
settle with the preimage, and the receiver, or sorry,
the sender is able to learn that and have
this sort of like proof of payment.
So building on that, we have AMP, which is the proposals
at the moment are kind of going on at the same time.
So Rusty is sort of championing the first one
we just talked about.
I have a proposal currently to do this.
And they're very similar in a lot of respects.
So they're kind of going on concurrently
in the spec process.
And basically, you can think of AMP
as adding additional fields onto that protocol
that we just talked about.
One of the main differences is, like I said,
the sender supplies all the randomness.
And that means that I will not learn any preimage.
For some people, this is a bigger deal than for others.
There are arguments for and against.
But to me, I think, so that is probably the one trade-off
that you, or the one downside, I guess,
won't someone say to this approach.
But you unlock a lot of really cool features in addition.
One is that the invoice becomes reusable.
If I'm generating the randomness every time I want to pay,
I can do that endlessly and continue
to pay this invoice, right?
If the receiver has to generate a preimage
and then give it back to me, I can't use that invoice anymore.
And to pay again, I have to actually contact them
to generate one and give it to me.
But if the sender is generating the randomness,
then I can continue to reuse this multiple times.
Again, you also get this sort of like,
it's a little bit more private, because you
can't correlate sort of these sub-payments just
by looking at their payment hashes.
And we'll get to a little bit into more why those are,
or how we actually derive those.
And finally, I think this is probably
one of the most requested features
that I've seen on Slack.
And just like people talking to me in person at meetups
is this idea of spontaneous payments,
or what Roastbeef calls key send.
And this is the idea where you don't even need an invoice
at all to make a payment.
I can just sort of send an HTLC to some node's public key,
and they can either choose to accept or deny
this sort of like donation, this HTLC that came out of nowhere,
and I'm just going to choose to accept it.
In case you're curious, this is kind of what we have as sort
of like this AMP record, AMP TLV record.
The set ID sort of functions similar to that payment
address or whatever on the prior slide,
just to sort of like, if I'm making concurrent payments,
like concurrent payments to the same invoice,
remember these are now reusable, you
want the receiver to be able to say,
oh, this is part of payment one and payment two
if they're going at the same time.
So we can kind of unbundle them if they arrive out of order.
The root share is, the things to note on this
is the root share in the child index.
And we'll see on the next slide how those are used.
So if I'm going to make an AMP payment,
I start by generating sort of 32-byte random values,
what we call these root seed shares.
And these are going to go in that TLV record,
in that root share field, for every HTLC.
They're all different and all random.
The sender can calculate a root seed
by exoring them all together.
So that's sort of like reconstructing them.
And then he'll actually take the child index, which
is that last field in the record.
So you see the S1, R1, S2, R2, S3, S3.
So the child index is like the 1, 2, 3s.
And using that, the receiver can sort of take this value, R,
and the child index, and derive down each tree.
So what the sender does is it takes,
it basically drives this whole tree
and then makes HTLCs with all the child hashes.
It pays out to those child hashes.
Then once the receiver gets all the HTLCs,
it takes those S values at the top that it got in the payload,
exhorts them together, and then re-derives the preimage.
So like the second to last step.
And using that, it settles the payment.
And so the key here is that once all these sort of sub-payments
have arrived at the destination, or until all those payments
have arrived, they don't know the actual shares.
And so they can't actually do this reconstruction
and derive all the preimages.
But once they do, that sort of unlocks the receiver
to be able to do that.
So now I'm going to go into a little bit more
of a classification of these different payment types.
So like I said, today we kind of have one payment
type on the network.
And within the next couple of months,
we'll probably be adding another six or so,
according to my taxonomy.
One of the interesting things to note is that all these multi-path
payments have a base case of one payment.
So I can make an AMP payment that only has one HTLC.
And so what you can do is you can
replace our existing single-shot payments with these schemes
and share all the logic.
So it's much less code pass.
It also is a nice entry point, so where
you don't have to add all this multi-receiving capability
on the sender to start making use of these features.
And really the way that this taxonomy breaks down,
one comment on that last point is that more or less
the general grade-upon direction is as we move forward,
like this current payment type that we use today
will probably be deprecated in favor of just always
using this MPP or AMP as like your standard payment type,
even if you're only making a single HTLC.
So who generates the HTLC pre-images?
We saw in that first type, the MPP or base AMP,
that this receiver generates them.
And then the payment has to be transferred via the invoice.
In the AMP one, the sender is generating them
and doing this crazy derivation tree.
The next question is, does the sender need an invoice?
We talked about this ability to do spontaneous key send
payments, and that also has to do with whether or not
there was an invoice involved.
If you have to do this receiver-generated pre-images,
then you are going to require an invoice.
But in the case where the sender is generating them,
you have this optionality to have the invoice for tracking
or generate them as you need and just send payments
in this sort of a spontaneous world.
And finally, is the payment actually a single or multipath?
And so what that brings us to is this chart.
So on the first column, you have the first payment type
we talked about, the multipath, like base AMP.
The second column is the AMP with the secret sharing
and all that derivation tree.
And the final column, key send, is AMP but with no invoice.
And again, all of these have sort of two flavors,
where it's single or multipath.
And just to kind of go through these acronyms
that I made up, we have, and the first one
is pay to one-time invoice.
And below that, multipath pay to one-time invoice,
pay to recurring invoice, multipath pay
to recurring invoice, and then pay to node key,
multipath pay to node key.
So I just kind of made these up to kind of simplify it.
But yeah, I think it's kind of an interesting way
to think about it.
And these are sort of like six different payment types
that will probably be deployed, like I said,
in the next three to six months, I would guess.
They won't hold me to that.
And so just sort of like a logical progression
of how that might roll out, probably
start with pay to one-time invoice,
just like using the multipath payment MVP records and stuff
to deploy single-shot payments.
Then you would sort of do this pay to recurring invoice
if you wanted to have a simple subscription service where
you're sending single HTLCs.
This is super useful.
Some exchanges have requested this ability
to have a deposit invoice and a withdrawal invoice
that you can just pay endlessly to or withdraw endlessly to.
And that's nice, because if you have these recurring invoices,
they can also act as an account where
they track every HTLC that the exchange has ever
received from that user.
Or you as the user can see every payment
you've ever withdrawn from the exchange.
And again, you can also kind of do subscriptions with that.
This pay to node key, which is going to be tip it on me.
You want this.
Tips and donations.
You can sort of like, without any coordination,
I can just pay any node on the network,
as long as assuming they have like, mostly if they're public,
you can do private, get some other roundabout ways.
But they're very cool, because they can basically
allow you to do this without having to get an invoice first.
And that is kind of more like, along maybe I
have a contact book functionality,
where I know the person's pub key,
and I just like try to send it out.
And I can just keep doing that sort of like Venmo style.
And finally, like you'd have sort
of like adding the multipath receiving capabilities.
This is kind of cool, because it effectively
skirts a lot of the max HTLC sizes on the network
currently at the moment, because you have that 1 to 1 correlation
that limits the basically effectively the total payment
size you can make.
But now if you can make, if you can start those payments,
you can sort of get around that limit by, you know,
horizontally, let's say.
This will be cool in the MP2OTI case,
for a loop in a loop out.
This is really, really cool, because I
can do a single on-chain transaction
and balance multiple, like all of my channels all at once.
Either like I pay out of them or receive
into like multiple channels.
So you can really amortize the on-chain cost there.
And then finally, you kind of end up with this,
deploying these MP2RI and MP2NK last.
And I would probably expect the like multipath receiving
to kind of be interleaved somewhere along those first
three, just because we already have
a lot of proofs of concept in terms of code and stuff
like that.
But this is sort of like a logical progression
and how that might go.
So if you guys weren't bullish enough on Bitcoin today,
bump it.
All right, I think we're out of time for questions.
But thank you.
Thank you.
Where stage two talks are, if you just
walk through this door over here,
I believe they are on the top floor.
So that's where that is.
And I'm kind of disappointed.
We aren't seeing really any memes at all.
Like that was the first meme we've seen.
Really, like no one's got a Bitcoin fixes it meme.
Let's do this.
Hashtag TLC2019.
Let's see some Bitcoin fixes this memes.
I want to see that.
And look, our next speaker is Christian Decker.
And he's always talking about L2.
So maybe L2 fixes this, right?
So give us an L2 fixes this meme.
But this time, for once, he's not speaking about L2.
He's speaking of channels, flows, and icebergs.
So let's put your hands together and welcome Christian.
So good morning.
Who's disappointed that I'm not going to talk about L2?
I see.
Oh, whoa, whoa, whoa.
We can talk offline, and I'll bore you
some more with the details.
So today, I'm going to talk about measurements
I did in the Lightning Network.
And why am I doing measurements in the Lightning Network?
Well, first of all, I wanted to mix it up a bit
and not talk about L2 again, obviously.
The second one is that apparently, I
am an old pony that can do very few tricks.
And measurements is exactly what got me started doing my PhD.
I measured how decentralized the network in Bitcoin is.
And that was basically the basis for an entire PhD.
So hopefully, this will inspire you to do some academic research
as well.
And on the other side, we also need to have some ground
truth, some real numbers to put behind and drive
our development when we further develop Lightning.
And this is sort of my attempt to give you
this basis point of what we can improve
and what we can achieve over time.
So what I did is I went out, looked
at a few aspects of the Lightning Network,
and I'm here to report on the results.
These results are by no means complete,
but they should serve as a jump-off point for you
to do your own research and to sort of look
at data that's presented to you and try to figure out
if that's really true or whether you should do your own research.
OK, I structured this in three broad topics.
The first one is going to be the surface layer,
or what can we get from gossip in the network itself.
So gossip is basically the nodes chatting among themselves,
what channels exist, what nodes exist,
what are the parameters of the channels.
And this is done basically to allow you,
like Fabrice mentioned before, to computer route
to get from you to your destination
or from anywhere to anywhere else, actually.
So what we do is we basically take a node
and dump its view of the network topology, and we look at it.
And these are probably the numbers
that you already saw in tens of thousands of publications
already.
This is the easy numbers to get at,
and this is basically what everybody's quoting.
So since inception of the Lightning Network,
we've had a rapid and sort of steady-ish grow
with some bumps in the middle.
And since these are the numbers that are sort of always
mentioned, I'll just rattle them off.
There's 4,400 nodes active at the time I was measuring.
That was two days ago.
829 of them are publicly reachable,
meaning that they accept incoming connections
through Tor, through IPv4, IPv6, and a total of 27,394
channels.
Now, these numbers change all the time,
so take it that that's basically the snapshot I
had available when I was measuring,
and a total capacity of over 800 bitcoins.
So I'm expecting to see a few puzzled faces in here.
Didn't I read about 10,000 channels
and finally making it to a 10k network?
It turns out that the network view that you have of the network
is highly dependent on how you measure it.
So the 10,000 node number usually comes from 1ML,
and they tend to not clean up nodes and channels that
have been defunct for a while.
So this is basically what Sea Lightning
sees by cleaning up every channel that have not
been active for the last two weeks,
and this is basically what your routing decisions
will depend upon.
It's also worth mentioning that this is only
the public part of the network.
There is a large part of the network
that is simply not announced.
Those might be mobile nodes, nodes
that do not expect to be online for routing purposes later on.
So there's little point in them being
announced to the wider network, because, well, you
will not be able to use them.
More on that later.
This is boring part over.
Let's get to the interesting part.
Let's actually test the functionality,
and this is a bit more involved, because it actually
involves setting up a node and performing
some payments in the network.
And the way we do this is by performing probes.
A probe basically is I take a dump of the network,
basically extract all of the node IDs in the network.
Then I iterate through these node IDs
and try to send them a payment.
Easy, right?
Well, there's one issue, though, which
plays in our favor, namely, I don't have an invoice.
Then again, I don't want to send people actual money.
I just want to see if I can reach them.
So what we do is I pick a destination.
I randomly generate a payment hash.
So that basically means that this payment will never ever
be able to complete, because it doesn't match
an invoice on the recipient side.
I compute a route to that destination,
and then I initiate the payment.
Now, this payment will fail, because, well,
it hopefully fails.
Otherwise, we do have bigger issues,
like hashing being broken.
Once the failure comes back, we look at the failure
and then determine what has failed in the network.
The failure might be some intermediate channel
being out of capacity, some intermediate channel
being offline, some intermediate channel being dead,
or one of the nodes being dead, or something else going wrong.
There's lots of failure cases, and we
have a bit of a discussion on a blog post
that we published describing this probing mechanism.
Now, we did that for all the nodes in the network,
all 4,400 nodes.
And you can probably see that this is kind of a worst case
scenario, right?
I am an endpoint, and I want to send
to every other endpoint in the room a payment.
So I'm just trying to prepare you mentally for the bad news
that are to come.
So yeah.
But since most of us are techies,
I thought I might just show some code as well,
just to show how easy it is in C Lightning
to create a plugin that does a probe.
So this is basically the bullet list we had before in code.
And it's really like 15 lines of code.
And this is even pretty printed.
So like I said before, the next slide contains results,
and I don't want anybody to have a heart attack when I show them.
So be prepared.
There's going to be a lot of red here.
But I have good excuses for them.
So this is basically the first result that is interesting here
is we pick a destination, we try a probe once,
and then we look at this failure.
So this is one attempt.
And we see that there is sort of a lot of red.
So why?
The majority of that, you see the inner circle
is mostly covered by the darker red.
That is a failure to compute a route from us
to the destination.
Now, why might that be?
Well, because some channel on the path was disabled.
And we do broadcast channel state
on the Lightning Network so that we don't even
attempt those channels if we try to perform a payment.
And these 48% were basically us being
unable to reach that node in any possible way.
And this was a bit disconcerting.
So we went out and actually hacked
Sea Lightning to return routes anyway.
And it turns out, yes, that is accurate.
Now, I don't want you to be scared of this result
because, let's see, how many people
are running a Lightning node?
How many of those nodes are offline right now?
OK.
And you're still the most enthusiastic crowd
about this stuff.
So it's very likely that these are nodes
that are running on someone's laptop, on someone's phone,
and they simply went to sleep.
So I expect this chart to have a diurnal pattern for people
going to work, turning on their machines,
turning it off again.
And a weekly pattern, people going into the weekend
and turning off their machines.
So, yes, we will see how this involves over time.
So I'm planning to do these measurements over and over
again.
But, yeah, that's not the nicest graph,
which is why we are going to ignore that part of the graph.
Because if we can't reach it, there's
nothing more to learn about that.
We see that there is also a big green part.
That's basically the first payment attempt goes through.
And we are able to perform the payment
without any further attempt.
Everything went good.
Perfect.
The yellow part on the left-hand side
tells us, yeah, this failed.
But it's not final.
We still have other routes we can try.
So let's try a new route and see what comes out.
OK.
Now, for the rest of this, I will just ignore the red part.
Because, well, there's little to be learned from there.
But if we clean up that red part,
we get a 66% success rate on the first try.
Now, that's encouraging.
So for 66% of the nodes that we could reach,
that we could perform a payment, we
will succeed in the first attempt.
And given my focus on the first attempt,
you might have guessed it, we're just going to retry until we
succeed.
So on the right-hand side, we have the same plot,
but with us retrying over and over again
until we reach one of the final states,
final states being, OK, the payment succeeded.
Or we ran out of routes we could try.
So the improvement is rather nice.
We still have a tiny sliver that is yellow.
That is mostly because I stopped at 25 attempts.
Because, well, you have to stop somewhere.
Our failure rate now is 20%, which is OK in my book.
And you notice that we actually have part of the unable
to find route again.
That's simply because when we retry, we retry, we retry.
Eventually, we run out of routes we can try.
So that's the reason for that.
But we get an 80% success rate.
Remember also that I mentioned that this is the worst case.
This is us making payments from some random node
to some other random node in the network.
So if we have an economic node, a business,
like Jameson said before, they are
likely to be much more connected,
to have a higher uptime.
And therefore, this is a lower bound on what we can expect
payments to succeed or not.
OK, now these are numbers that do not have any timing
information in them just yet.
So I also looked at the time until success,
or time until completion in this case.
On the left-hand side, we have the number of attempts
until we actually get to a final state.
And like I said, about 66% of them
will succeed in the first attempt.
And we have a 90th percentile of four attempts.
So after four attempts, we will have
succeeded in 90% of the cases.
And only in 10% of the cases, we will
have to perform more attempts.
On the right-hand side, we have the same numbers,
but in wall clock time.
So each attempt takes a bit of time.
And the more attempts I do, the longer
it takes for my payment to complete.
Now, it's kind of bad if I order a coffee.
We're using Lightning, expecting it to be quick.
And it's still slower than my Bitcoin payment
would have been on chain.
But luckily, that's not the case.
So the plot on the right-hand side
shows you that we have a 90th percentile of 30 seconds, which
is by no means optimal, so 90% of the payments
go through in 30 seconds.
And the disappointing part here is that, well,
we have a 95th percentile of almost three minutes.
So in 5% of the times, you actually
have to stick around for three minutes plus for your payment
to complete.
The positive side here is that this is a baseline.
This is the network as it is today.
And this is what we are going to improve on going forward.
And these numbers will guide us towards making better decisions.
One example of an improvement in this case
would, for example, be instead of having them have a testing
path sequentially, we might be able to actually probe
in parallel for working routes and then have the probes race
against the first attempt.
And if that fails, we have a number of options
we can actually try.
So there's already ways we can reduce this massively
in very little time.
And now for the boogeyman in the room, of course,
by performing lots of payments, I also
had a few stuck payments.
Fabrice mentioned before that stuck payments are really
the bane of the Lightning Network
because they are really, really bad.
Luckily, it turns out, they're not that often.
So a stuck payment, as I define it here,
is basically a payment that I initiated.
But somewhere along the path, one of the nodes
just died on me.
So I don't know whether I crossed that gap
that this dying node created and this payment will eventually
complete or whether the payment is stuck in front of it
and it will never complete.
And I basically could retry directly.
The reason I cannot retry right away
is that the payment might still go through.
And in that case, I would have paid twice,
which is kind of not what I want.
But it turns out that out of the 8,000 probes
that I sent out doing this test, only 14 got stuck.
So this is a stock rate of 0.19%.
And in reality, it was even a bit better
because I just simply stopped waiting for them
once my test run was over.
It turns out that two more completed
after my run completed.
And we only really got 12 stuck payments.
So that's quite a nice number to have.
But we can still improve it.
And we do have a few proposals on the table
for stuckless payments that would allow you to basically
abandon one attempt and retry immediately
without incurring the risk of paying twice.
So this is basically that this was the surface.
Then we looked into the functional testing
of the network and now for the submerged part of the network.
I mentioned before that when gossiping,
we do exchange information about channels and nodes
that are in the network.
That's only partially true.
There are nodes that opt out of announcing this information
because they want to stay private,
because they don't believe that they can contribute
to the routing of payments.
And so we wanted to take a look at the invisible part
of the network.
How do we do that?
Well, basically, we look at the footprint
that a lightning channel leaves on the blockchain itself.
And we have a few heuristics that work there.
So the first heuristic is that the funding output
script is unique.
Basically, every time that we open a channel,
we create new Bitcoin keys.
And both endpoint Bitcoin keys get combined
into a new output script.
And so this script may never be repeated.
A closing transaction only ever has one single input.
That is because, well, it's spending the funding output
of the channel.
Unilateral closes may have non-final sequence numbers.
We'll ignore that for now.
But it's useful to determine whether close
was cooperative or uncooperative, which
is an interesting metric that I haven't looked into just now.
The funding transaction only ever has, at most, two outputs.
Well, it's the funding output and change.
It turns out that this is no longer true
since we merged one of the pull requests on C Lightning,
because now we can combine where CoinJoin multiple channel
opens.
So this heuristic will have to be dropped in the future,
probably.
And finally, only one of the funding outputs
is a P2WSH, because the other one is basically
paying back to a private key and not to a script.
And yes.
So we trailed through the blockchain
from the time Segwit was activated up until, I think,
Wednesday.
And it turns out that we have 195,000 outputs that
would match these heuristics.
And by comparing that with the historic gossip
in the network, which I've been collecting since we started
this whole experiment, it turns out
that out of those 195,000, 135,000 were gossiped about.
So we only have about 60,000 channels that are not
part of the public network.
But this is likely to grow once people
start creating more private wallets
and basically stop announcing themselves
to the network as a whole.
So the subsurface part of the iceberg is not very big,
but hopefully it will grow.
And that's basically my numbers.
In conclusion, I hope I could give you
some idea of what the network looks
like about the directions we should go into to develop
further.
And maybe there is one PhD candidate
that wants to look into this.
It's an amazing topic to work on.
And I can only suggest you take a look for yourself.
Thank you.
Thank you, Christian.
All right, awesome.
Well, thanks for hanging in with us.
We only have one more talk before lunch.
And I don't know about you, Stefan,
but I'm kind of feeling like a roast beef sandwich.
Oh, yeah.
That's a good idea.
It'll cost you one LSAT.
It's your ticket aboard the internet's money rails.
All right, we have roast beef.
Let's give it up for Lalu.
OK, cool.
Cool.
All right, hey, my name is Lalu, or Lalu Last.
So those of you who call me roast beef in person,
as well, or in the internet, I'm going
to talk about something called LSAT.
We're going to be asking, exactly, what's
the internet's money rails?
The internet's money rails are basically
Bitcoin and Lightning itself.
We have existing rails, which are very slow.
They're opaque.
There's no API docs.
You can't really build on top of it very easily.
While we have Lightning now, it's
basically a new opportunity to actually redo
all these things for the first time over.
And I guess if you're asking what the ticket is,
as you've seen a little bit, it's kind of like an API, right?
So my talk is going to be mostly about,
how do you actually build a new server
on top of Lightning itself that is actually
Lightning-native for the first time itself?
So this is more about, how do you build a new API
and service on top of Lightning itself,
rather than doing, maybe, point-of-sale pavements,
something like that.
A little bit more on the back-end side of things.
Here's a little outline for us to talk about keys
and the abstract, and exactly what they are,
and how they're different from other things.
Authentication modes, because if I'm
going to be using a service, I need to somehow authenticate
with the service itself.
Macaroons, maybe some of y'all know about this, kind of like
something we use in L&D, pretty popular thing as far as finding
great authentication.
Basically, how APIs work today, and then
how I envision them working in the future.
And then once we go on that, we get something called 402,
which maybe some people know about that, really, it's HTTP.
And then finally, again, it's exactly what an LSAT is.
It has things about, basically, deployment and specification
once you see how everything goes along.
First, we have keys.
So I guess what is this?
This is an API key, basically, right?
This is basically something you can have.
You have to lock.
You can give it to your friend.
Specifically, it's like a credential.
So basically, if you have the key, you have access
to the entirety of exactly what it unlocks for you, right?
If I have a key, I don't need to ask somebody to use it.
I can basically plug it into the door,
and then boom, I can use it right there.
So one thing is, like, bare base.
Once again, you actually have it in your hand.
You can actually give it to somebody else very easily,
as well.
It can also be delegated.
I can give my key to my brother, my friends,
or whatever else they need to access my house,
and they don't need anything else but the key itself.
Revocation is possible.
So whenever I revoke a key, I can basically
change the locks, more or less.
And at that point, you can't really use it.
Obviously, it's a very involved process where I can do this rotation, invalidate all of the API keys that have these actual physical keys, landing and interaction between any of the users.
And yeah, so many rotations are possible.
Also, it's kind of a decentralized-ish.
You can take a key and actually go and copy it somewhere.
It's like a locksmith or whatever else and give it to them and hand it to anyone else.
And that's a pretty cool part about it, as well.
Also, that's kind of like fine-grained access.
You can imagine maybe I have a front door and a back door and a side door.
I can give you keys to each one of them.
You could even say maybe I have some time-locked doors, as well.
Maybe it only works within a particular time of the day.
And then finally, we also have the possibility of a master key.
So I basically have one key that works for every other key, as well.
And it's kind of like a cool concept along with it, as well.
So now we go to another type of key.
Here is another key, which is kind of like, once you get an API key, maybe something you're a little bit more familiar with.
This is basically more or less like a username.
Maybe it's like a base-58 or base-64 actual key.
But it's a little bit different.
This is basically kind of like an access control list or an ACL.
There's a type over there.
That's not linked.
That should be a list itself.
But basically, the way it works is you basically have your privileges in the access control list itself, right?
So rather than like action-microdential, basically having all the details about what access is into the service, it more or less lies on the back end.
So it's like I have Alice.
I'm also able to read and write a particular thing for this key.
It's a little bit different.
So it's basically like two different models, capabilities versus ACLs, right?
And replication here is also easy, because at this point, I can just actually just modify the things on the back end.
I don't need to contact anyone else.
Maybe it's a little bit easier than doing it for capabilities.
I don't need to change the lock.
I basically can just change everything else in the background itself.
And the other thing about this, too, is that mutations on the ACL may not really affect any other individual, as well.
I can basically just add maybe like read prime or something like that to Alice's thing, and then go from there.
This is also kind of a little more centralized, because I have to go to that provider and actually get this information from them directly.
That may be just like giving my API key to someone else.
The other thing, as well, is possibly duplicate a little bit easily.
And it also adds a little more coarse-grained access.
That was like a leftover from something else.
But it can be coarse-grained, typically.
And then it's always pretty widely used.
People use it for like OAuth, HTTP authentication, whatever else.
It's probably the default thing used today, typically, to kind of access the web.
So I was kind of thinking, when I'm designing these services in Lightning Labs, it's like, how do we have these new forms of APIs?
Maybe have some of these new traits that we want in these APIs.
Basically, make them a lot more easy for developers and allow these things to be hooked up a little more seamlessly across the web.
And like I said, we're using the AWS.
People probably used this many times before.
So we'll take a detour to Macro Boons.
I guess some people would say those are like macros, but I'm going to throw on the same bucket for this.
So it's basically a cryptographic bearer credential, right?
And what I mean by this is basically it's a bearer credential.
I kind of like that key.
But it uses some cryptography to basically give us authentication, also integrity, and also unforgeability, which is pretty cool.
So you can actually forge one of those keys.
I can go take someone else.
I can maybe just copy it and maybe the door would accept it.
In this case, it can't really be forged because you actually need this kind of like secret material to actually make the key itself.
So it's basically made to be this kind of like chain HMASH construction, right?
So typically, you have like a root secret key.
Once I have a secret key, that's kind of like, you know, at the server, no one else can actually access that.
I use that root secret key to then drive every single key down below.
This is really cool because it's actually unforgeable, like we were saying.
You can't make a fake key because, you know, I, the server, have the key itself.
So that means it can't be duplicated pretty easily.
It's also pretty easily authenticated.
So basically, the way you check it, you basically start with the root Macro Boon secret, then you actually kind of like hash down maybe some capabilities,
maybe like your Alice, you know, read, write, or whatever else.
And so it's a very easily authenticated by any other individual.
Once again, very, very easy, easily verifiable.
Another cool thing about it as well is like, you know, because we have the chain HMASH construction going down,
hash function is kind of like a one-way construction, you can't really go back up, right?
So if I give Alice like a capability to like read on Tuesdays, she can't take that and say read on Wednesdays, right?
Because once again, you basically have to invert the hash function and then modify, you know, Tuesdays to Wednesdays and then go back down again.
And the cool thing about it as well is like delegation is possible.
So I can basically just give you a Macro Boon.
You can actually then even like attenuate it, meaning you actually have one level down.
Let's say I give you something that says you can read on Tuesdays.
I can then take that and you say you can read on Tuesdays at 1 p.m., right?
So I can always make it weaker. I can never make it go stronger again.
I can just hash down as normal as we go.
Another cool thing about this basically has a very like, you know, fine-grained authentication.
So rather than like read and write, maybe I can say you can like read the particular endpoint,
or maybe you can maybe like, you know, pay, you can have maximum of like one million soshis and so on,
or you kind of have some like must, kind of like direct way, you must do this along with your provider of information.
Another cool thing, you can basically also kind of authenticate data along with the Macro in itself,
which we'll be using a little shortly as far as the way we're going to construct this new thing that we call an LSAT.
So let's just kind of like, you know, go and review the way things work today.
Typically, API keys are kind of obtained from a central source.
The other thing about them is they're also typically based on common subscription-based billing.
So maybe I have API keys in AWS. I can just keep taking it.
Maybe at that point, if I forget about it, they just keep draining my bank account or my credit card or whatever else.
Typically, they also evade your credit cards basically, you know, using the legacy rails,
not like the new internet money rails, you know, lightning and so forth.
And this is kind of like, you know, not very good because you actually, you know, kind of unblock,
you block a lot of people in the population from actually using these API keys themselves, right?
Now, everyone has credit cards, therefore, they may not be able to access all these cool resources on the internet.
Maybe it's one that makes this a lot more widespread use, a lot more widespread manner.
Now, typically, it's all distributed maybe via like a side channel.
So rather than like me actually obtaining the API key directly through the protocol,
unless it's kind of a thing like that, maybe you always have some like additional kind of like thing you need to talk on the side.
So we typically also obtain it via kind of like WebSAR or login.
And another thing with this, typically, it's like dangerous to share with others
because if you have the API key, you maybe like, you just lose all capabilities.
And at that point, someone can drain, you know, maybe your resources, maybe like mine, you know, cryptocurrency on like your cloud account or something else like that.
So the question I had is basically, can we do better?
So like this kind of like maybe came, I came up with this idea maybe like a year or so ago,
working on some new services, working on Lightning Labs, soon to be deployed.
And, you know, it came with this idea of basically if the net has some new money,
why can we kind of like redesign the way we actually do API keys and make them a lot cooler, right?
So now here's the new vision, right?
So basically, we want them to be decentralized by nature, you know,
the ability to basically like pass them around between other individuals,
maybe even obtain it from many other individuals as well.
We want to kind of like have like metered billing, so it's kind of like a pay-as-you-go type of thing.
Maybe I'm paying for like, you know, these credit slides ago, maybe it's like a video thing, maybe it's like pictures,
maybe it's even some kind of like, you know, machine learning as a service API or something like that.
And we want to also like have it be natively obtained from Lightning.
So basically, we're going to swap out the old rails with the new rails.
This makes it a lot more accessible.
The cool thing about this, we actually have zero login required at all.
There's no login, there's no credit cards.
Basically, I can just access the thing directly from the API.
API, like I said earlier, is kind of like you start to take my money and do the service,
and then I have this API key and I go along with that.
And maybe there's something for exchange, if you guys know kind of like how atomic swaps work, there's a little bit kind of capabilities that we use along with that too.
And then the cool thing is basically you have like kind of like protocol over distribution, right?
So I want this all to be within protocol because I want this to be for developers.
Basically, developers interact with these services and also maybe servers interact with themselves.
And maybe this protocol is maybe built.
Maybe it's HTTP, maybe it's HTTP2, or a GRP, which some of you know that I want to use.
And GRP is actually just like a superset of HTTP.
So yeah, GRP uses HTTP2 as a transport, like everything else.
The cool thing about this is the Beatles 2 also attended with other individuals, right?
So let's say I have like maybe like an Android phone. I have kind of like intent on Android phones, which let me, you know, pass the capabilities to other individuals.
I can say, okay, hey, you know, on my Android phones, maybe like send payments of one of those Toshis and then give that to another application.
Maybe restrict that down. They can only send one Toshi every day or something like that.
So I basically have a very cool authentication model.
We send all these different individuals in a decentralized way because any time you attenuate,
you never need to go back to the actual provider in order to get the new key.
You can just like do that yourself and actually attenuate it down and give it to another individual.
And yeah, that's why it's.
And then the cool thing, you can actually maybe even have these be tradable with other service partners yourself, right?
Let's say I have an API key. Let's say for a reason, maybe the cost goes up.
Maybe it's like a little bit, you know, it gets really hot in the future.
I can actually trade within the way I can trade these APIs with each other individuals.
Once again, you can have like an atomic drop protocol as well.
I like, you know, credits for like this space and this space gets very expensive.
Maybe for some reason, I have an API key and I can then like sell it for a higher price and some like open market perhaps.
Click. All right, cool. So now we'll get into kind of like the instruction of exactly how it's working.
So I'm going to focus on HTTP initially because it's a little bit simpler than maybe some HTTP or JRPG.
Some people know this code called HTTP for two payment required.
Basically, you know, it's kind of like HTTP. We have like things like OK, you know, authentication required or maybe, you know, the server errors and like that.
And more is more or less basically a way to signal that some payments are required before you are able to access a particular service, right?
And typically, you know, it's not mostly like unused.
But I think when I saw this, I was like, OK, wow, that has to be Bitcoin basically.
Like what else are you going to be using on the Internet going forward?
And here's kind of like a strongman protocol the way it could work possibly.
So first, the client issues a request. It's kind of like, you know, get some V1, the API, HTTP dot one, one dot one.
And what would be the host is like, you know, some cool site. I want to ask what's going on.
They have a cool API server then responds with a challenge, right?
The challenge is once again, we sense back the reply is HTTP for two payment required.
It's basically not going to actually it's not going to give the client the response until it actually makes this payment.
And then in the header, we have this new kind of authentication method just called LN for now has an invoice.
Right. What happens now, like the client then pays the invoice and then reaches the request, you know,
attaching the, you know, the invoice along with the invoice and premium along with it itself.
The server then checks that the premium matches the invoice and boom, it can go everything by itself.
The cool thing with this is actually the server itself just needs to get an invoice from the lighting node.
But beyond that, whenever it's checking any of these responses, it can be completely like offline or not offline,
which can be more or less stateless, right? Because they can actually verify the invoice was properly paid.
It can verify that the node actually signed the invoice to create the invoice itself and also that the premium was, you know, properly crafted.
So what we what we get with this, we basically get kind of like a rate limiting in a sense,
because we can actually not raise the price of service, you know, and kind of price it depending on like what's going on.
We also get some degree of civil resistance as well. And just even with it, we kind of get like a degree of like login, right?
I can just take that kind of like tuple of the LN invoice and also the premiums together.
And that's like now my login to any particular site.
So there's no email and maybe like I want to have some persistent session that I can use this, you know, I can use this purpose to actually get that.
So this basically covers our payment. So we talked about we want also some capabilities, right?
We want the ability to like be able to kind of like have like finding reaction in particular services.
So questions like how do we do that?
So click. This is where else that comes in. So the font is smaller.
This is going to be the heavy slide in the the kind of presentation.
So, you know, it's fair with me on this. So LSAT stands for Lightning Service Authentication Token.
It's not the like, you know, law school admission test.
I'm kind of co-opting that instead, and we're going to be doing something a little bit cooler.
And so basically kind of like a lightning native, you know, macro based API credential.
So once again, there's something that you just want to have, you know, actually the service itself.
You don't need any of the individual to maybe authorize you and do anything else.
So along with what we get before, we also get maybe some application level adoption.
We also get this really cool thing and kind of like fine grained authentication as well.
So we're going to go over the kind of protocol now, kind of like hop around the client server side.
So basically you can view this kind of like a superset and what I presented just a little bit earlier.
Basically, how do we actually do the entire thing with the LSAT protocol?
So now we have a new server response, server response.
Once again, you know, payment forward to required.
Now we have a slightly different authentication headers, right?
So we have LSAT before with, you know, LN. Now we have the macro in there.
The macro in there is basically, you know, kind of like what your capability is.
We also have like an invoice once again.
It's like one thing to know as well as like the macro is actually now like half complete.
So the LSAT in totality is actually the macro along with the preimage.
So what happens, like now the actually server sends a half complete macro over to the client.
It gets completed once the client actually pays the preimage.
So this kind of like an example is they have like, you know, some ID, you know, we're doing loop out.
This is like the first tier and maybe I have like a max of like 1K, you know, loops using this thing.
Or maybe that's even like 1K starts to use up that itself.
One important thing to know is like now the actual macro commits to the payment hash,
which is very important because this is another thing as far as like authentication, also unforgeability.
Because now and they have things as well like a loss to give a divorce along with it,
which also sign also commits to the payment hash and the macro as well.
So everything is fully authenticated.
Now we have the client side macro completion.
Basically, they pay the invoice and they actually get the preimage.
Once they have the preimage, they can complete the macro.
So now the macro is now like now the LSAT itself is like the macro and the preimage along with it.
So basically, this is like similar to the invoice thing.
But now we have a lot more information in the macro itself.
The service can actually use to dispatch any resources back to the client.
And so then reaches the request.
Does it get with HTTP 1.1?
But now we have some new headers.
New header is basically the authorization header.
And we have the LSAT is kind of like the resource type or the authorization type.
Now we pass in the macro and the preimage together and then boom.
Now we have our end-to-end macro in itself.
The proxy of the verification is pretty simple as well.
Just verifies the signature of the macro.
So once again, the macro is actually unforeseeable and actually ensures that this is actually crafted by the server.
No one else can actually make a fake macro.
And they finally have the ability to just for the proxy itself to actually verify the macro is actually done properly.
So basically half the preimage, make sure it matches the pay hash and then boom.
Now we have everything there.
It's also cool because now the requests are authorized.
It's also cool because it's actually fully stateless.
So rather than like having like a new database look up or it's like, you know, maybe New York for SQL,
every single time a request comes in, we actually just do this once at the end.
It's pretty cool. So yeah.
All right. Click. Moving on.
So this is what we have. We have LSAT.
So we see like decentralized API credentials of lightning.
You know, lightning native using the money rails.
No login, no stop. All the payments happen.
It can be metered. You know, we do a bunch of cool stuff with it.
And like we're saying before, we gain a bunch of cool things for like rate limiting.
We get also kind of like layer seven application dash for this.
And this is like, you know, the OSI stack layers.
So not like layer seven, some super duper lightning.
This is like, you know, an application layer.
You know, we have like the presentation session right below that.
And we have some cool future extensions.
One you can actually kind of like have, you can use the server itself to actually assist trading of these LSAT tokens.
But you're kind of like an atomic swap.
So basically the way you do this, you have your regular LSAT token,
then you have a new LSAT token, which commits to the prior one and then now has two payment hashes.
One of them from the server is normal, another one from the actual participant.
So when I pay you for this thing, then I actually complete the new LSAT token itself.
This is how we can do atomic swap of these kind of API key credentials, which is pretty cool.
Many simplifications as far as like, you know, trading API keys with some like trust in the market, like we were saying before.
And then deployment wise.
So we're actually going to be rolling this out pretty soon to the loose loop river, you know, coming near you.
Where we have to do this to kind of like have different capabilities on the end clients.
Maybe have different fee tiers, maybe have different capabilities.
We can also use maybe roll out some kind of like new features as far as like A-B testing on the side as well, too.
And this is going to be probably like default authentication method,
maybe like thing that we make as Lightning Labs.
You know, we have some other things coming out too pretty soon.
And we have this like demo right here.
So like if you guys remember some of these, you know, some of the HTTP requests I actually did, you can type those in manually.
I mean, if you were like, you know, want to be hardcore, you can use like curl or something like that and hit this site right here.
Basically, this is a site where we actually have some information about like what kind of like good news or what we think are good news networks.
Something we've been working on for a while, coding kind of like a boss core thing.
And we also have some other things coming along as far as like specification, you know, client side library and also for HTTP to support.
So in the call, I'm sorry, in this talk, I describe mostly HTTP support.
HTTP2 is basically a similar thing.
We're actually going to use the Galaxy headers, which is a slightly different format.
Then we also have GRPC on top of that.
This is also ability to actually have a GRP service that speaks LSAT natively.
We have these things called a client interceptor, which basically is a way you kind of interrupt a request or response on the client or the server side.
So it'd be very easy to kind of like plug it into your own service and maybe to basically have this new, you know, kind of like payment aware of reverse proxy for any of the servers that you have coming out.
And yeah, that's it. Any questions?
I have a lot of time left.
So if you guys have questions, I have 15 minutes.
I can just show up here otherwise.
I guess I have 30 total.
But yeah, I think there's one here, too.
Hey, just wondering about these LSATs, would they be able to support something like a streaming service or something like that?
Where I don't know, like how exactly would that work?
Yeah. So, I mean, so you can sort of like GRPC because every single request and response can also carry a new challenge header as well.
I can do like, you know, request, request, request. You give me a response. OK, forward to required.
You basically need, you know, for the next 20 minutes of the video, that's your new LSAT token.
We keep going from there. So you can actually do the streaming.
You can actually do the authentication kind of like bi-directionally in the GRPC stream or even HTTP to kind of check encoding or kind of like things like that.
Yeah, that's kind of what I was thinking of.
But I was also wondering how that would affect, like, performance, because Macaroon has the signature requirement.
So like a lot of a lot of streaming apps and stuff like that have a lot of latency. Oh, definitely. Yeah.
One thing is like they call it a signature, which really just kind of like, you know, symmetric cryptos.
You're just hashing the entire time. Hatching is pretty simple.
You know, it's pretty easy to parallelize.
And also we have like really good, you know, optimizations for like assembly and things like that.
So it's not it's not really a digital signature. It's all symmetric cryptos.
It makes it pretty quick. OK. Yeah, you say it's decentralized by nature, but an API provider can deny service to a given Macaroon, right?
Sorry, can you repeat the first part? The API provider can deny service based on the Macaroon, right? Sure.
Yeah, can you use like something like ring signatures to avoid the API providers to deny service to a given Macaroon without denying service to all the IP credential viewer or something like that?
OK, you're saying like you want to reveal that like my identity in the Macaroon itself.
No, no, no, no. I mean, I can deny you providing the service based on the Macaroon, right?
Because I can identify it from the payment is what you mean? Yeah.
I mean, you sign the Macaroon, right? So you can.
The client doesn't. The client never signs. The server does, yes. Indirectly.
Can you use like ring signatures or something like that to avoid?
Possibly. I guess it depends. Like they can always kind of like deny you access because it's like there is a particular service.
I guess you could get some anonymity as far as like being able to not tell which Macaroon I have here.
But yeah, so I guess every individual got together and kind of like you had a signature of all the Macaroons,
maybe some like Merkle tree is on the server side as far as all the possible Macaroons or that have been created, then something like that would be possible.
So you'd be able to say, OK, I have one of these and I don't reveal basically who I am,
maybe when I paid for it, but then I can actually have that server even more anonymity in the service.
Yeah, it can also be over Tor as well. So you don't really reveal the location.
It could be over many other transfers as well, too. So yeah.
How do you track timeouts like this Macaroon is valid for 20 minutes kind of thing, especially with caching?
Caching is supposed to be stateless. So how does it know that this thing is already being used?
Yeah, good question. So basically, like you can add that as like a caveat on the Macaroon itself.
You can basically have an expiration time or like some deadline as well.
So because the other thing is, well, like the client can't mutate that once again because it actually has the full HMAC change.
So I can give you Macaroon, this is OK, this expires in one day.
So then one day you must actually look this up in the other code as well.
Like, you know, because we pushed much of the storage of the LSTOKEN to the Macaroon to the client side,
the server side of the situation is a lot simpler. There's a lot less state, right?
Because you're basically giving me what I should, where I can verify the LST for the Macaroon itself.
I can look up the time and say, OK, boom, this expired, reject, and then you have to like buy another one, possibly.
OK, but I can't get a Macaroon that says like one hour worth of video to be spent whenever I feel like it.
Well, so yes, you can as well. So there's another one I want to talk about.
Kind of like a, you know, per request discharge in a sense.
So basically, like let's say like you buy like the first five minutes because you have one hour left.
I give you a new Macaroon, you have 55 minutes left, right?
You keep going from that. And then so now at that point, I basically need kind of like some simple, you know, revocation state on the server side.
Similar to kind of like, you know, Rick's pictures for like the key image.
Then at that point, I can basically keep, I can ensure that I can once again push the storage requirement over to you,
but then always, always have this Macaroon that can itself be, you know, kind of like meter in a sense.
So either I store that on the server side as far as the amount of time left for that particular ID,
or I basically put that onto the client side, which is a little bit better solution in my opinion,
because then it makes things a lot easier and it's mostly stateless at that point.
Thanks a lot. My question is, are you going to provide some more centralized way to store and manage Macaroons,
not just like files, maybe some database or some secret storage like that?
Yeah, yeah, yeah, definitely. Like there's like super old, I think it's an LOD called like to make like a Macaroon pouch or like a cookie jar.
So basically you basically have this kind of maybe like kind of like a client-side encrypted database that you actually store your Macaroons in,
because there are capabilities after all, because the capabilities, if you have access to it, you can use it immediately.
So basically, yeah, we could have some additional kind of like, you know, a storage system on the client side for these things,
because they are kind of like sensitive, you know, cryptographic material as well.
Thanks.
No problem.
So I've heard a lot of talks about extensions this morning.
Extensions?
Yeah, extensions on Lightning. What are they? What is the scope that they provide?
And on an implementation level, what happens like if one node supports the extension and another node doesn't, like a relay supports and, you know, you don't, for example?
Like I guess elaborate on what they are, please.
Okay. Yeah, I mean, so basically there's a few formats.
Like one is kind of like what we have like is feature-based, basically, whenever different peers connect or even like an announcement,
you basically have kind of like a bit field, basically, and that bit field signifies a particular feature understanding on your end, right?
So if I connect to you, we both have the same feature.
That means you can actually use this new protocol, you know, aside from the specification itself.
That's cool because basically that's kind of like more rapid experimentation between the end nodes.
One other thing that we have as well is like in Lightning, there's kind of like a requirement that every single message can be powered up to basically six to five kilobytes.
So anything at the end that you don't understand, you can basically just ignore, right?
So what we can do now, let's say like we both integrated a new feature.
I can then now add this new feature or new, you know, even fields at the end of the existing message in a way that we don't really need to kind of break anything else because typically all clients should basically ignore that data.
So it's also like forwards and backwards compatible as well, which is pretty cool.
Do you think these could be used to track an identity across multiple services?
And do you see any privacy implications of that similar to how on the web today, you know, cookies can be used to track and profile across sort of multiple services to be able to tie together an identity?
Yeah, that's a good question.
So, you know, there's no requirement that a user actually uses the exact same LSAT for their entire lifetime.
They can get them as they go, right?
So every single new site can actually get a new LSAT.
They can also even have several different LSATs per particular site to maybe even like, you know, increase their own MIDI set as well.
We also have the idea from Antoine over there, but maybe having some sort of like rigor signature protocol on top of it as well for you to have more identity.
But yeah, so there's no requirement that you have like one login.
I can always be Bob, Bob one, two, Bob three, Bob four, as I want.
So it's a lot better for tracking at that point because you can basically opt out to it.
Yeah, opt out of it rather.
It seems to me that the sum of like you could the sum of a bunch of attenuated macaroons, the value of that could be larger than the parent macaroon.
Meaning like if I was AWS, I could be like, I'm going to give I'm going to sell, you know, space or processing power for like the entire year.
And then I'm going to interface with somebody who can then resell that to other people.
Do you see that being a potential that, you know, the individual macaroons like once the market actually like prices those that the higher value than the parent macaroon?
Possibly. Yeah, I guess like the thing there just like basically like, you know, it's tradeable as long as the actual provider allows to be traded because the protocol I have mine for tradeability actually requires some interaction on behalf of the provider.
So they could kind of like possibly clamp down on the market if they wanted to because actually providing it at the end.
But that could be the case where it's like maybe like a year is like, you know, too big, too big an adventure kind of like chop our contract into smaller bits.
So here's like a one day contract or two day contract, which is maybe maybe we're talking like one year because I don't need one year of this space.
I'm going to like some quick demo to hack day. I only want like 30 seconds of like CPU or something like that.
So definitely possibly.
All right, Denzel. All right, cool.
You all have six extra minutes then.
All right. Yeah, the jet lag definitely didn't slow him down today.
Awesome. Yeah, so we are going to be able to break a little bit early for lunch.
So if you just go out this door and to the right, there are three different lines. So if you can kind of use those three different lines will help everybody get through a little bit faster.
And also, there's just one portion per person. So we don't really have enough for seconds since we have so many folks here.
Yeah. And just remember, we're starting back up at 130. So just be back before then.
Be a good be a good channel participant. Don't go offline for too long. Thanks, guys.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
thank good.
Yes.
Thank you.
sessions.
Thank you.
Thank you.
Thank you.
And so, and so it was.
I leave a perverted passion.
Dear companions,
I hope you listened to our conversation.
I'm glad you liked it.
It was a great pleasure.
Now I would like you to listen to our conversation.
Thank you.
When he left,
the time of my past came.
And we have to fight.
We have to believe in life.
And so he left.
I leave a perverted passion.
And so he left.
I leave a perverted passion.
I leave a perverted passion.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you!
Thank you.
Thank you.











































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































